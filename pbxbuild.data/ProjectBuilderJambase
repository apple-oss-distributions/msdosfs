# ProjectBuilder Jambase
# Copyright (c) 1999,2000 Apple Computer, Inc.
# All rights reserved.

CROSS_ROOT default = "" ;

JAMBASE_DIR default = $(JAMBASE:D) ;

OS default = macos ;
if $(OS) = MACOS {
    OS = macos ;
}

if OS != "" {
    include $(JAMBASE_DIR)/platform-$(OS).jam ;
}

# Copyright (c) 1999-2003 Apple Computer, Inc.
# All rights reserved.

# This file defines various functions for transforming text and
# manipulating variables

/ default = / ;

# NonObjectFiles <non-object files returned> : <list of files>
# Returns only files not in $(OBJECT_FILES_$(VARIANT)
# or $(OBJECT_FILES_$(VARIANT)_$(ARCH)) for ARCH in $(ARCHS)
rule NonObjectFiles
{
    $(1) = ;
    for X in $(2) {
        if ! $(X) in $(OBJECT_FILES_$(VARIANT)) {
            REJECT = ;
            for ARCH in $(ARCHS) {
                if $(X) in $(OBJECT_FILES_$(VARIANT)_$(ARCH)) {
                    REJECT = YES ;
                }
            }
            if ! $(REJECT) {
                $(1) += $(X) ;
            }
        }
    }
}

#
# RemovePrefixPath <variable> : <prefix> : <path-with-prefix>
#  removes the given prefix from the path and puts the result
# in the given variable
#
rule RemovePrefixPath
{
    local newname = $(3:BS) ;
    local newdir = $(3:D) ;
    local INDEX ;
    if $(2) != "." {
	for INDEX in 1 2 3 4 5 6 7 8 9 10 {
	    if $(newdir) != $(2) {
		newname = $(newdir:BS)/$(newname) ;
		newdir = $(newdir:D) ;
	    }
	}
    }
    else {
	newname = $(3) ;
    }
    $(1) = $(newname) ;
}
# Copyright (c) 1999-2003 Apple Computer, Inc.
# All rights reserved.

# Built-in definitions of common build settings.  These can be
# overridden by any higher layer (project-level, target-level,
# build-phase-level, command-line etc).

# the four 'root' directories
export deferred SRCROOT = $(PWD) ;
export deferred OBJROOT = $(SYMROOT) ;
export deferred SYMROOT = $(SRCROOT)/build ;
export deferred DSTROOT = /tmp/$(PROJECT_NAME).dst ;

# synonyms for the above
export deferred SOURCE_ROOT = $(SRCROOT) ;
export deferred TEMP_ROOT = $(OBJROOT) ;
export deferred BUILD_ROOT = $(SYMROOT) ;
export deferred INSTALL_ROOT = $(DSTROOT) ;

# more specific directories inside the TEMP_ROOT
export deferred TEMP_DIR = $(OBJROOT)/$(PROJECT_NAME).build/$(TARGET_NAME).build ;
export deferred DERIVED_FILE_DIR = $(TEMP_DIR)/DerivedSources ;
       deferred OBJECT_FILE_DIR = $(TEMP_DIR)/Objects ;
       deferred CLASS_FILE_DIR = $(TEMP_DIR)/JavaClasses ;
       deferred FILE_LIST = $(OBJECT_FILE_DIR)/LinkFileList ;
       deferred PRECOMP_TRUSTFILE = $(TEMP_DIR)/TrustedPrecomps.txt ;

# more specific directories inside the BUILD_ROOT
export deferred BUILD_DIR = $(SYMROOT) ;

# more specific directories inside the INSTALL_ROOT
export deferred INSTALL_DIR = $(DSTROOT)/$(INSTALL_PATH) ;

# installation parameters
export deferred INSTALL_OWNER = $(USER) ;
export deferred INSTALL_GROUP = $(GROUP) ;
export deferred INSTALL_MODE_FLAG = "ugo-w,o+rX" ;

# language-independent code generation settings
       deferred OPTIMIZATION_LEVEL = 0 ;
       deferred OPTIMIZATION_CFLAGS = -Os ;
       deferred DEBUGGING_SYMBOLS = YES ;
       deferred PROFILING_CODE = NO ;
       deferred PREBINDING = YES ;

# Java-specific (some are marginally obsolete)
       deferred JAVA_ARCHIVE_CLASSES = YES ;
       deferred JAVA_ARCHIVE_TYPE = JAR ;
       deferred JAVA_APP_STUB = $(SYSTEM_LIBRARY_DIR)/Frameworks/JavaVM.framework/Resources/MacOS/JavaApplicationStub ;
       deferred JAVA_JAR_FLAGS = cv ;
       deferred JAVA_SOURCE_SUBDIR = . ;
       deferred JAVA_FRAMEWORK_RESOURCES_DIRS = Resources ;
       deferred JAVA_FRAMEWORK_JARS = ;
       deferred JAVA_USE_DEPENDENCIES = YES ;
       deferred JAVA_FORCE_FILE_LIST = NO ;
       deferred JAVA_ZIP_FLAGS = -urg ;
       deferred JAVAC_SOURCE_FILE_ENCODING = MACINTOSH ;

# miscellaneous
export deferred DEVELOPMENT_LANGUAGE = English ;
export deferred FRAMEWORK_VERSION = A ;
       deferred REMOVE_CVS_FROM_RESOURCES = YES ;
       deferred COPY_PHASE_STRIP = NO ;
       deferred CLONE_HEADERS = NO ;
       deferred KEEP_PRIVATE_EXTERNS = YES ;   # this currently affects the master.o file only
       deferred USE_GCC3_PFE_SUPPORT = YES ;
# We avoid setting a default value for this for Project Builder 2.1, so that lower-level tools can pick their own default.
#export deferred MACOSX_DEPLOYMENT_TARGET = 10.2 ;


rule ConditionalDefinitions
{
    # default mapping of build actions to build variants
    switch $(ACTION) {
        case build : deferred BUILD_COMPONENTS = headers build ;
        case copysrc : deferred BUILD_COMPONENTS = source ;
        case copyhdrs : deferred BUILD_COMPONENTS = headers ;
        case copyrsrcs : deferred BUILD_COMPONENTS = resources ;
        case install : deferred BUILD_COMPONENTS = headers build ; 
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
        case installdebugonly : deferred BUILD_COMPONENTS = build ;
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
         deferred BUILD_VARIANTS = debug ;
        case installprofileonly : deferred BUILD_COMPONENTS = build ;
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
         deferred BUILD_VARIANTS = profile ;
        case installdebugprofileonly : deferred BUILD_COMPONENTS = build ;
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
         deferred BUILD_VARIANTS = debug profile ;
        case installhdrs : deferred BUILD_COMPONENTS = headers ;
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
        case installsrc : deferred BUILD_COMPONENTS = source ;
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
        case installrsrcs : deferred BUILD_COMPONENTS = resources ;
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
    }

    # conditional locations enabling install-in-place
    if $(DEPLOYMENT_LOCATION) = YES {
        if $(SKIP_INSTALL) || ! $(INSTALL_PATH) {
            export deferred TARGET_BUILD_DIR = $(TEMP_ROOT)/UninstalledProducts ;
        }
        else {
            export deferred TARGET_BUILD_DIR = $(INSTALL_ROOT)/$(INSTALL_PATH) ;
        }
        deferred BASE_PROJECT_HEADER_DIR = $(TEMP_ROOT)/ProjectHeaders ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES {
            # built products go in subfolder when there are asides
            export deferred BUILT_PRODUCTS_DIR = $(BUILD_ROOT)/BuiltProducts ;
        }
        else {
            # built products go in build folder when there are no asides
            export deferred BUILT_PRODUCTS_DIR = $(BUILD_ROOT) ;
        }
    }
    else {
        export deferred TARGET_BUILD_DIR = $(BUILD_DIR) ;
        export deferred BUILT_PRODUCTS_DIR = $(BUILD_DIR) ;
        deferred BASE_PROJECT_HEADER_DIR = $(BUILD_ROOT)/ProjectHeaders ;
    }
}
# Copyright (c) 1999-2003 Apple Computer, Inc.
# All rights reserved.

# Maps legacy Makefile variables to modern Jambase variables
# Set global C flags, architectures, and architecture flags for linking
GLOBAL_CFLAGS default = $(RC_NONARCH_CFLAGS) ;
ARCHITECTURES default = $(RC_ARCHS) ;
SUPPORTED_ARCHITECTURES default = i386 ppc ppc64 ;
VALID_ARCHS default = i386 ppc ppc64 ;
for ARCH in $(SUPPORTED_ARCHITECTURES) {
    if $(RC_$(ARCH)) = YES {
        $(ARCH) = YES ;
    }
}

# More compatibility definitions for things that we have
# renamed that we had already told external users about
export deferred TEMP_FILES_DIR = $(TEMP_DIR) ;
export deferred DERIVED_SOURCES_DIR = $(DERIVED_FILE_DIR) ;
export deferred BUILD_PATH = $(TEMP_ROOT) ;

export deferred PROJECT = $(PROJECT_NAME) ;
export deferred TARGETNAME = $(TARGET_NAME) ;

# (the following four are build settings to the generated package files
#  written by PBXCore -- the new names have underscores to indicate that
#  they are private, and they have more consistent names -- we should
#  be able to remove the old compatibility settings soon)
export deferred PRODUCT_SETTINGS_PATH = $(_INFO_PLIST_FILE_PATH) ;
export deferred PKGINFO_FILE_PATH = $(_PKGINFO_FILE_PATH) ;
export deferred VERSION_SETTINGS_PATH = $(_VERSION_PLIST_FILE_PATH) ;
export deferred DEVELOPMENT_SETTINGS_PATH = $(_PBDEVELOPMENT_PLIST_FILE_PATH) ;
# Copyright (c) 1999-2003 Apple Computer, Inc.
# All rights reserved.

# !!!cmolick:20000821 hardcoded tool paths because variables not set yet
APPLE_INTERNAL_TOOLS default = /AppleInternal/Developer/Tools ;
SYSTEM_DEVELOPER_TOOLS default = /Developer/Tools ;
# Variables for invoking commands using explict paths
# except where built in shell functions should be used
ASM		default = /usr/bin/as ;
BRIDGET         default = /usr/bin/bridget ;
# CC defined in BeginProduct rule based on value of GCC_VERSION and other settings
CD		default = cd ;
CHMOD		default = /bin/chmod ;
CHOWN		default = /usr/sbin/chown ;
CP		default = /bin/cp ;
DITTO		default = /usr/bin/ditto ;
ECHO            default = echo ;
EGREP		default = /usr/bin/egrep ;
FASTCP		default = /usr/lib/fastcp ;
FIXPRECOMPS	default = /usr/bin/fixPrecomps ;
FIND		default = /usr/bin/find ;
GATHERHEADERDOC default = /usr/bin/gatherHeaderDoc ;
HEADERDOC2HTML	default = /usr/bin/headerdoc2html ;
INTERFACER	default = $(APPLE_INTERNAL_TOOLS)/Interfacer ;
JAR		default = /usr/bin/jar ;
export JAVA_COMPILER	default = /usr/bin/javac ;
export JAVACONFIG	default = /usr/bin/javaconfig ;
# LD defined in BeginProduct rule based value of GCC_VERSION and other settings
LEX		default = /usr/bin/lex ;
LIBTOOL		default = /usr/bin/libtool ;
LN		default = /bin/ln ;
LNRESOLVE       default = $(SYSTEM_DEVELOPER_TOOLS)/lnresolve ;
MAKEPSEUDOLIB	default = $(APPLE_INTERNAL_TOOLS)/MakePseudoLibrary ;
MERGEINFO	default = /usr/lib/mergeInfo ;
MKDIR		default = /bin/mkdir ;
MIG		default = /usr/bin/mig ;
MV		default = /bin/mv ;
NMEDIT		default = /usr/bin/nmedit ;
OSAC		default = /usr/bin/osacompile ;
OSAL		default = /usr/bin/osalang ;
OSAS		default = /usr/bin/osascript ;
PBXCP		default = $(SYSTEM_DEVELOPER_TOOLS)/pbxcp ;
RANLIB		default = /usr/bin/ranlib ;
REGGEN		default = reggen ;
RESMERGER	default = $(SYSTEM_DEVELOPER_TOOLS)/ResMerger ;
RESOURCE_PRESERVING_CP default = $(SYSTEM_DEVELOPER_TOOLS)/CpMac ;
REZ		default = $(SYSTEM_DEVELOPER_TOOLS)/Rez ;
RM		default = /bin/rm ;
RPCGEN		default = /usr/bin/rpcgen ;
SED		default = /usr/bin/sed ;
SETFILE		default = $(SYSTEM_DEVELOPER_TOOLS)/SetFile ;
SH		default = /bin/sh ;
STRIP		default = /usr/bin/strip ;
TOUCH		default = /usr/bin/touch ;
UNZIP		default = /usr/bin/unzip ;
XARGS		default = /usr/bin/xargs ;
YACC		default = /usr/bin/yacc ;
ZIP		default = /usr/bin/zip ;

# Basic operations:

# Rm <files>
# Removes <files> from the filesystem.  Note that the actions are only
# executed once, no matter how many times the rule is invoked.
actions together piecemeal Rm
{
    $(RM) -r $(1:Q)
}

# Mkdir <directory>
# Creates <directory>
rule Mkdir
{
    # Only existence of the directory matters
    NOUPDATE $(1) ;
}
actions together piecemeal Mkdir
{
    $(MKDIR) -p $(1:Q)
}

# MkEmptyDir <directory>
# Makes a directory if necessary, and insures it is empty
actions together MkEmptyDir
{
    ( $(MKDIR) -p $(1:Q) && $(CD) $(1:Q) && $(RM) -rf "*" )
}

# SymLink <link> : <to>
# Makes a symbolic link to the path indicated.
# Link target is treated as a nonfile to preserve the value
rule SymLink
{
    if ! $(2) in $(PRODUCT_FILES) && $(2) != $(PRODUCT_CLASS_FILE_DIR) {
        NOTFILE $(2) ;
    }
}
actions SymLink
{
    $(LN) -sf $(2:Q) $(1:Q)
}

# Touch <files>
# Touches files in the filesystem.
actions Touch
{
    $(TOUCH) $(1:Q)
}

# TouchConditionally <fileToTouch> : <fileToCompareAgainst>
# Touches a file in the filesystem if <fileToCompareAgainst> is newer.
rule TouchConditionally
{
	DEPENDS $(1) : $(2) ;
}
actions TouchConditionally
{
    $(TOUCH) $(1:G=:Q)
}

# Echo <file> : <text>
# Echoes text into a file.
rule Echo
{
    local FILE ;
    NOTFILE $(2) ;
    Echo.remove $(1) ;
    for FILE in $(2) {
        Echo.append $(1) : $(FILE) ;
    }
}
actions together piecemeal quietly Echo.remove
{
    $(RM) -rf $(1:Q)
}
actions quietly Echo.append
{
    $(ECHO) $(2:Q) >> $(1:Q)
}

# ChangeOwnerAndGroup and ChangeMode to use when installing files
# All these use the -H option to avoid traversing bad symbolic links
rule ChangeOwnerAndGroup
{
    if $(INSTALL_OWNER) {
        if $(INSTALL_GROUP) {
            ChangeOwnerAndGroup.Action $(1) ;
        }
        else {
            ChangeOwner.Action $(1) ;
        }
    }
}
actions ChangeOwnerAndGroup.Action
{
    if [ -e $(1:Q) ]
      then $(CHOWN) -RH $(INSTALL_OWNER):$(INSTALL_GROUP) $(1:Q)
    fi
}
actions ChangeOwner.Action
{
    if [ -e $(1:Q) ]
      then $(CHOWN) -RH $(INSTALL_OWNER) $(1:Q)
    fi
}
actions ChangeMode
{
    if [ -e $(1:Q) ]
      then $(CHMOD) -RH $(INSTALL_MODE_FLAG) $(1:Q)
    fi
}

# Strip <target>
# Runs strip to remove debugging symbols from the executable of the target
actions Strip
{
    $(STRIP) $(STRIPFLAGS:Q) $(1:Q)
}

# SetFile <fork file>
# Appends type and creator to a file
rule SetFile
{
    local MACOS_TYPE_ARG ;
    local MACOS_CREATOR_ARG ;
    if $(MACOS_TYPE) {
        MACOS_TYPE_ARG = -t '$(MACOS_TYPE)' ;
    }
    if $(MACOS_CREATOR) {
        MACOS_CREATOR_ARG = -c '$(MACOS_CREATOR)' ;
    }
    SETFILEFLAGS on $(1) = $(MACOS_TYPE_ARG) $(MACOS_CREATOR_ARG) ;
}
actions SetFile
{
    $(SETFILE) $(SETFILEFLAGS:Q) "$(OTHER_SETFILEFLAGS)" $(1:Q)
}

# Rez <fork file> : <target file>
# Appends resource fork data to a file
rule Rez
{
    local MACOS_TYPE_ARG ;
    local MACOS_CREATOR_ARG ;
    DEPENDS $(1) : $(2) ;
    if $(MACOS_TYPE) {
        MACOS_TYPE_ARG = -t '$(MACOS_TYPE)' ;
    }
    if $(MACOS_CREATOR) {
        MACOS_CREATOR_ARG = -c '$(MACOS_CREATOR)' ;
    }
    REZFLAGS on $(1) = -append -d SystemSevenOrLater=1 $(MACOS_TYPE_ARG) $(MACOS_CREATOR_ARG) "$(OTHER_REZFLAGS)" ;
    if ! $(REZ_EXECUTABLE) = "YES" {
        # by default use data forks
        REZFLAGS on $(1) += -useDF ;
    }
}
actions Rez
{
    $(REZ) $(2:Q) $(REZFLAGS) -o $(1:Q)
}

# ResMerge <fork file> : <rsrc file>
# Merges the resources from binary resource file 'rsrc file' into 'fork file'
# CAUTION: OTHER_RESMERGERFLAGS (with R) are used for RESMERGEFLAGS (no R)
rule ResMerge
{
    local MACOS_TYPE_ARG ;
    local MACOS_CREATOR_ARG ;
    DEPENDS $(1) : $(2) ;
    if $(MACOS_TYPE) {
        MACOS_TYPE_ARG = -fileType '$(MACOS_TYPE)' ;
    }
    if $(MACOS_CREATOR) {
        MACOS_CREATOR_ARG = -fileCreator '$(MACOS_CREATOR)' ;
    }
    RESMERGEFLAGS on $(1) = -append $(MACOS_TYPE_ARG) $(MACOS_CREATOR_ARG) "$(OTHER_RESMERGERFLAGS)" ;
    if ! $(REZ_EXECUTABLE) = "YES" {
        # by default use data forks
        RESMERGEFLAGS on $(1) += -dstIs DF ;
    }
}
actions ResMerge
{
    $(RESMERGER) $(2:Q) $(RESMERGEFLAGS) -o $(1:Q)
}

# RezCollector and ResMergerCollector either compile
# resource manager resources together, or split compiles
# by file with the first compile being treated differently.
# This code assumes collectors will be declared product files
# only after the first Collector rule evaluation.
rule RezCollector
{
    DEPENDS $(1) : $(2) ;
    REZFLAGS on $(1) = -d SystemSevenOrLater=1 -useDF ;
    REZPATHFLAGS on $(1) = ;
    for _REZ_PATH in $(REZ_SEARCH_PATHS) {
        REZPATHFLAGS on $(1) += -i $(_REZ_PATH) ;
    }
    if $(REZ_TOGETHER) = YES {
        RezCollector.together $(1) : $(2) ;
    }
    else {
        if ! $(1) in $(PRODUCT_FILES) {
            RezCollector.initial $(1) : $(2) ;
        }
        else {
            RezCollector.append $(1) : $(2) ;
        }
    }
}
actions together piecemeal RezCollector.together
{
    if [ -f $(1:Q) ]; then
        _appendoption=-append
    fi
    $(REZ) -o $(1:Q) $_appendoption $(REZFLAGS:Q) "$(OTHER_REZFLAGS)" $(REZPATHFLAGS:Q) $(2:Q)
}
actions RezCollector.initial
{
    $(RM) -f $(1:Q) && \
    $(REZ) -o $(1:Q) $(REZFLAGS:Q) "$(OTHER_REZFLAGS)" $(REZPATHFLAGS:Q) $(2:Q)
}
actions RezCollector.append
{
    $(REZ) -o $(1:Q) -append $(REZFLAGS:Q) "$(OTHER_REZFLAGS)" $(REZPATHFLAGS:Q) $(2:Q)
}

rule ResMergerCollector
{
    DEPENDS $(1) : $(2) ;
    RESMERGEFLAGS on $(1) = -dstIs DF ;
    if $(REZ_TOGETHER) = YES {
        ResMergerCollector.together $(1) : $(2) ;
    }
    else {
        if ! $(1) in $(PRODUCT_FILES) {
            ResMergerCollector.initial $(1) : $(2) ;
        }
        else {
            ResMergerCollector.append $(1) : $(2) ;
        }
    }
}
actions together piecemeal ResMergerCollector.together
{
    if [ -f $(1:Q) ]; then
        _appendoption=-append
    fi
    $(RESMERGER) -o $(1:Q) $_appendoption $(RESMERGEFLAGS:Q) "$(OTHER_RESMERGERFLAGS)" $(2:Q)
}
actions ResMergerCollector.initial
{
    $(RM) -f $(1:Q) && $(RESMERGER) -o $(1:Q) $(RESMERGEFLAGS:Q) "$(OTHER_RESMERGERFLAGS)" $(2:Q)
}
actions ResMergerCollector.append
{
    $(RESMERGER) -o $(1:Q) -append $(RESMERGEFLAGS:Q) "$(OTHER_RESMERGERFLAGS)" $(2:Q)
}

# ResMergerProduct - used to transfer collector resources to final destination
rule ResMergerProduct
{
    local MACOS_TYPE_ARG ;
    local MACOS_CREATOR_ARG ;
    DEPENDS $(1) : $(2) ;
    if $(MACOS_TYPE) {
        MACOS_TYPE_ARG = -fileType '$(MACOS_TYPE)' ;
    }
    if $(MACOS_CREATOR) {
        MACOS_CREATOR_ARG = -fileCreator '$(MACOS_CREATOR)' ;
    }
    RESMERGEFLAGS on $(1) = $(MACOS_TYPE_ARG) $(MACOS_CREATOR_ARG) -srcIs DF "$(OTHER_RESMERGERFLAGS)" ;
    if $(REZ_EXECUTABLE) = "YES" {
        ResMergerProductResourceFork $(1) : $(2) ;
    }
    else {
        RESMERGEFLAGS on $(1) += -dstIs DF ;
        ResMergerProductDataFork $(1) : $(2) ;
    }
}
actions ResMergerProductResourceFork
{
    $(REZ) -o $(1:Q) < /dev/null && \
    $(RESMERGER) $(2:Q) $(RESMERGEFLAGS) -o $(1:Q)
}
actions ResMergerProductDataFork
{
    $(RM) -f $(1:Q) && \
    $(RESMERGER) $(2:Q) $(RESMERGEFLAGS) -o $(1:Q)
}

# Fixprecomps <precomp> : <header>
# Ensures that the precompiled header is up to date
if $(FIXPRECOMPS) {
    rule Fixprecomps
    {
        DEPENDS $(1) : $(2) ;
    }
    actions Fixprecomps
    {
        $(FIXPRECOMPS) -precomps $(1:Q)
    }
} else {
    rule Fixprecomps
    {
        # if we don't have a fixprecomps command, we'll just
        # quietly do nothing
        NOTFILE $(1) ;
    }
}


# Copy operations:

# Cp <destination> : <source>
# Reliably copies files only.
# Leaf names of the source and destination are expected to match.
rule Cp
{
    DEPENDS $(1) : $(2) ;
}
actions together piecemeal Cp
{
    $(CP) $(CPFLAGS:Q) $(2:Q) $(1:Q)
}

# PBXCp <destination-file> : <source-file>
# Reliably copies files only.  Does not currently respect Mac OS
# Finder info or resource forks, but it does skip CVS directories
# and it does optionally strip Mach-O executables.
# Leaf names of the source and destination are expected to match.
rule PBXCp
{
    if $(ACTION) != installhdrs {
        DEPENDS $(1) : $(2) ;
    }
    PBXCP_FLAGS on $(1) = ;
    VERBOSE_PBXCP default = NO ;
    if $(VERBOSE_PBXCP) = YES {
        PBXCP_FLAGS on $(1) += -V ;
    }
    PBXCP_FLAGS on $(1) += -exclude .DS_Store ;
    if $(REMOVE_CVS_FROM_RESOURCES) = YES {
        PBXCP_FLAGS on $(1) += -exclude CVS ;
    }
    if $(COPY_PHASE_STRIP) = YES  &&  $(ACTION) != installhdrs {
        PBXCP_FLAGS on $(1) += -strip-debug-symbols ;
    }
    # Because any content copied may have been generated, and so may be
    # in the form of a symlink to the actual content, it is necessary
    # to resolve one level of symbolic link for all sources copied.
    PBXCP_FLAGS on $(1) += -resolve-src-symlinks ;
}
actions together piecemeal PBXCp
{
    $(PBXCP) $(PBXCP_FLAGS:Q) $(2:Q) $(1:DQ)
}

# Ditto <destination> : <source>
# Directory to directory copies.
rule Ditto
{
    DEPENDS $(1) : $(2) ;
}
actions Ditto
{
    $(DITTO) $(2:Q) $(1:Q)
}

# RobustCp <destination> : <source>
# RobustCp is like Cp, but is made more robust by first removing
# any previous copy results and then conditionally removing CVS
# directories from the destination.
rule RobustCp
{
    if ! $(ACTION) = installhdrs {
        DEPENDS $(1) : $(2) ;
    }
    if $(REMOVE_CVS_FROM_RESOURCES) = YES && $(DEPLOYMENT_POSTPROCESSING) = YES {
        RobustCp.CleanBeforeAndAfter $(1) : $(2) ;
    }
    else {
        RobustCp.CleanBefore $(1) : $(2) ;
    }
    if $(COPY_PHASE_STRIP) = YES && ! $(ACTION) = installhdrs {
        StripBinaries $(1) ;
    }
}
actions RobustCp.CleanBeforeAndAfter
{
    if [ -d $(1:Q) ]
        then $(RM) -r $(1:Q)
    fi
    if [ -e $(2:Q) ]
        then
        _source=`$(LNRESOLVE) $(2:Q)`
        $(CP) -fRP "$_source" $(1:Q)
        if [ -d "$_source" ]
            then
            $(FIND) $(1:Q) -name CVS -type d -prune -print0 | $(XARGS) -0 rm -r
        fi
    fi
}
actions RobustCp.CleanBefore
{
    if [ -d $(1:Q) ]
        then $(RM) -r $(1:Q)
    fi
    if [ -e $(2:Q) ]
        then _source=`$(LNRESOLVE) $(2:Q)`
        $(CP) -fRP "$_source" $(1:Q)
    fi
}

# StripBinaries <starting directory>
# Uses find to run strip -s on all binaries starting from a file or directory
actions StripBinaries
{
    if [ -f $(1:Q) ]; then
        filetype=`file $(1:Q)`
        macho=`echo $filetype | fgrep Mach-O | sed 's/:.*//'`
        ararch=`echo $filetype | fgrep ar\ archive | sed 's/:.*//'`
        if [ "x$macho" != "x" ]; then
            $(STRIP) -S "$macho"
        fi
        if [ "x$ararch" != "x" ]; then
            $(STRIP) -S "$ararch"
        fi
    else
        machos=`cd $(1:Q); $(FIND) . -type f -print0 | xargs -0 file | fgrep Mach-O | sed 's/:.*//'`
        ararchs=`cd $(1:Q); $(FIND) . -type f -print0 | xargs -0 file | fgrep ar\ archive | sed 's/:.*//'`
        if [ "x$machos" != "x" ]; then
            cd $(1:Q); 
	    origIFS=$IFS
	    IFS="
"
	    for curbinary in $machos ; do
	    	$(STRIP) -S "$curbinary"
	    done
	    IFS=$oldIFS
        fi
        if [ "x$ararchs" != "x" ]; then
            cd $(1:Q); 
	    origIFS=$IFS
	    IFS="
"
	    for curbinary in $ararchs ; do
	    	$(STRIP) -S "$curbinary"
	    done
	    IFS=$oldIFS
        fi
    fi
}

# ResourcePreservingCp <destination> : <source>
# where the leaf names of <destination> and <source> are the same
# and CpMac is to be used to insure resources are preserved.
# Although CpMac is invoked with -r, this command is only reliable
# for individual file copies becaues there is no preremove of
# a directory destination which could cause nesting of the copy.
rule ResourcePreservingCp
{
    DEPENDS $(1) : $(2) ;
}
actions together piecemeal ResourcePreservingCp
{
    $(RESOURCE_PRESERVING_CP) -r $(2:Q) $(1:Q)
}

# ResourcePreservingMv <destination> : <source> : <junk>
# where the leaf names of <destination> and <source> are the same
# and CpMac is to be used to insure resources are preserved.
# The <junk> is removed after copying.
rule ResourcePreservingMv
{
    DEPENDS $(1) : $(2) ;
}
actions together piecemeal ResourcePreservingMv
{
    $(RESOURCE_PRESERVING_CP) -r $(2:Q) $(1:Q)
}

# AbsolutePathImportStub <stub file> : <stub import file>
# Generates a file with one line which is an #import directive
# and the second parameter quoted which should be a full path
# to the real file to be imported.
# If $2 is not an absolute path, $(SRCROOT) will be prepended to make 
# it absolute.
rule AbsolutePathImportStub
{
    DEPENDS $(1) : $(2) ;
    NOUPDATE $(1) ;
}
actions AbsolutePathImportStub
{
    firstChar=`echo "$(2)" | colrm 2`
    if [ z$firstChar = z"/" -o z$firstChar = z"~" ] ; then
        includePath="$(2)"
    else
        includePath="$(SRCROOT)/$(2)"
    fi
    echo "#include" \""${includePath}"\" > "$(1)"
}

# HeaderDoc <headerdoc target (table of contents for header)> : <header>
rule HeaderDoc
{
    DEPENDS $(1) : $(2) ;
}
actions HeaderDoc
{
    $(HEADERDOC2HTML) -o $(HEADERDOC_DIR:Q) $(2:Q)
}

# GatheredHeaderDoc <gathered headerdoc target>
rule GatheredHeaderDoc
{
}
actions GatheredHeaderDoc
{
    $(GATHERHEADERDOC) $(HEADERDOC_DIR:Q)
}

# Source derivation operations:

# Lex <file>.{c|m} : <file>.l[m]
# Runs lex to generate <file>.c or <file>.m based on scanner input
rule Lex
{
    DEPENDS $(1) : $(2) ;
}

actions Lex
{
    $(LEX) $(LEXFLAGS) "-o$(1)" $(2:Q)
}

# Yacc <file>.{c|m} <file>.h : <file>.y[m]
# Uses yacc to generate parser from description
rule Yacc
{
    DEPENDS $(1) : $(2) ;
}

actions Yacc
# Generate result by noting location, going to derived source directory,
# running yacc, then copying the results to what is desired.
{
    origin=`/bin/pwd` && $(CD) "$(1[1]:D)" && $(YACC) $(YACCFLAGS) -d "$origin/$(2)" && $(CP) y.tab.h "$(1[2])" && $(CP) y.tab.c "$(1[1])"
}

# RPCGen <proto>_xdr.c <proto>.h : <proto>.x
# Generates RPC stubs from specifications
#
rule RPCGen
{
    DEPENDS $(1) : $(2) ;
}

# Generate header and C code with two calls to rpcgen
actions RPCGen
{
    $(RPCGEN) $(RPCGENFLAGS) -h -o "$(1[2])" $(2:Q)
    $(RPCGEN) $(RPCGENFLAGS) -c -o "$(1[1])" $(2:Q)
}

# Mig <file>User.c <file>.h : <file>.defs OR
# Mig <file>Server.c <file>Server.h : <file>.defs
# Runs mig to create client and server files from a definition file.
rule Mig
{
    DEPENDS $(1) : $(2) ;
    if Server in $($(2)_ATTRIBUTES) {
        Mig.server $(1) : $(2) ;
    }
    else {
        Mig.client $(1) : $(2) ;
    }
}
actions Mig.client
{
    origin=`pwd` && $(CD) "$(1[1]:D)" && $(MIG) "$(OTHER_MIGFLAGS)" "$origin/$(2)"
}
actions Mig.server
{
    origin=`pwd` && $(CD) "$(1[1]:D)" && $(MIG) "$(OTHER_MIGFLAGS)" -sheader "$(2:B)Server.h" "$origin/$(2)"
}

# Bridget <primary target> : <jobs file>
rule Bridget
{
    # set up common settings and paths needed for bridget usage
    JAVA_HEADERS default = /Developer/Java/Headers /System/Library/Frameworks/JavaVM.framework/Headers ;
    if ! $(BRIDGET_FILES_DIR) {
        BRIDGET_FILES_DIR = $(DERIVED_FILE_DIR)$(/)JavaBridgeFiles ;
        Mkdir $(BRIDGET_FILES_DIR) ;
        ProductFile $(BRIDGET_FILES_DIR) ;
    }
    if $(BRIDGE_JAVA) = YES {
        # produce the file list draft
        # conditionally update the file list from the draft
        BRIDGET_DERIVED_JAVA_FILE_LIST = $(FILE_LIST:G=BridgetDerivedJavaFileList)BridgetDerivedJavaFileList ;
        NOTFILE $(BRIDGET_DERIVED_JAVA_FILE_LIST) ;
        DEPENDS $(1) : $(BRIDGET_DERIVED_JAVA_FILE_LIST) ;
        DEPENDS $(BRIDGET_DERIVED_JAVA_FILE_LIST) : $(2) ;
        DEPENDS $(BRIDGET_DERIVED_JAVA_FILE_LIST) : $(BRIDGET_FILES_DIR) ;
        DEPENDS $(BRIDGET_DERIVED_JAVA_FILE_LIST) : $(OBJECT_FILE_DIR) ;
        Bridget.UpdateJavaFileList $(BRIDGET_DERIVED_JAVA_FILE_LIST) : $(2) ;
        # derive files using file list
        # compile derived files (nonfile target?)
        BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG = $(FILE_LIST:G=BridgetDeriveAndCompileJavaTag)BridgetDeriveAndCompileJavaTag ;
        ProductFile $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) ;
        DEPENDS $(1) : $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(BRIDGET_DERIVED_JAVA_FILE_LIST) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(BRIDGET_FILES_DIR) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(CLASS_FILE_DIR) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(2) ;
        if $(JAVA_COMPILER:B) = jikes {
            Bridget. DeriveAndCompileJava.jikes $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(2) ;
        }
        else {
            Bridget.DeriveAndCompileJava.javac $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(2) ;
        }
    }
    if $(BRIDGE_OBJC) = YES {
        # Produce the derived C file list draft
        # and conditionally update the file list from the draft.
        BRIDGET_DERIVED_C_FILE_LIST = $(FILE_LIST:G=BridgetDerivedCFileList)BridgetDerivedCFileList ;
        NOTFILE $(BRIDGET_DERIVED_C_FILE_LIST) ;
        DEPENDS $(1) : $(BRIDGET_DERIVED_C_FILE_LIST) ;
        DEPENDS $(BRIDGET_DERIVED_C_FILE_LIST) : $(2) ;
        DEPENDS $(BRIDGET_DERIVED_C_FILE_LIST) : $(BRIDGET_FILES_DIR) ;
        DEPENDS $(BRIDGET_DERIVED_C_FILE_LIST) : $(OBJECT_FILE_DIR) ;
        Bridget.UpdateCFileList $(BRIDGET_DERIVED_C_FILE_LIST) : $(2) ;
        BRIDGET_DERIVE_AND_COMPILE_C_TAG = $(FILE_LIST:G=BridgetDeriveAndCompileCTag)BridgetDeriveAndCompileCTag ;
        ProductFile $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) ;
        DEPENDS $(1) : $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(BRIDGET_DERIVED_C_FILE_LIST) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(BRIDGET_FILES_DIR) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(OBJECT_FILE_DIR) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(2) ;
        # derive files using file list
        # compile derived files (nonfile target?)
        BRIDGET_FILE_LIST default = $(FILE_LIST)Bridget ;
        BRIDGET_CFLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) ;
        BRIDGET_CFLAGS on $(1) += -pipe ;

        # seed search paths with target-wide values
        if $(CPP_HEADER_SYMLINKS_DIR) {
            BRIDGET_CFLAGS on $(1) += "-I$(CPP_HEADER_SYMLINKS_DIR)" ;
        }
        HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
        FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;

        # We must compile with the extension-specific build flags
        BRIDGET_CFLAGS on $(1) += $($(2:S)_CFLAGS) ;
        # Add debug flags, if appropriate.
        if $(DEBUGGING_SYMBOLS) = YES {
            BRIDGET_CFLAGS on $(1) += -g ;
        }
        # Add profiling flags, if appropriate.
        if $(PROFILING_CODE) = YES {
            BRIDGET_CFLAGS on $(1) += -pg ;
        }
        # Pass the trusted-precomp file name to the compiler to keep track
        # of which precompiled headers it has already sanity checked.
        if $(OS) in MACOS DARWIN {
            BRIDGET_CFLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
        }
        if $(CPP_HEADERMAP_FILE) {
            BRIDGET_CFLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
        }
        if YES in $(GENERATE_CPP_ILOG_FILES) {
            local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(1:DB).ilog ;
            BRIDGET_CFLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
        }
        if $(PREFIX_HEADER) {
            PREFIX_HEADER_CFLAGS on $(1) += -include $(PREFIX_HEADER) ;
        }
        Bridget.DeriveAndCompileC $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(2) ;
    }
}
# Bridget.UpdateJavaFileList <list update target> <bridget file> generates draft
# and updates definitive list if it is missing or out of date
actions Bridget.UpdateJavaFileList
{
    $(BRIDGET) -listjava "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" >> "$(1:G=)Draft" && \
    if [ ! -e "$(1:G=)" ]; then
        cp "$(1:G=)Draft" "$(1:G=)"
    else 
        _file_list_diffs=`diff --brief "$(1:G=)Draft" "$(1:G=)"`
        if [ "x$_file_list_diffs" != "x" ]; then
            cp "$(1:G=)Draft" "$(1:G=)"
        fi
    fi
}
actions Bridget.DeriveAndCompileJava.javac
{
    $(BRIDGET) -java -o "$(BRIDGET_FILES_DIR)" "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" && \
    frameworkjars="" && \
    for i in `echo $(JAVA_FRAMEWORK_JARS)/*.jar $(JAVA_FRAMEWORK_JARS)/*.zip ` ; do if [ -f "$i" ] ; then frameworkjars="$frameworkjars":"$i" ; fi ; done && \
    classpath="$(CLASS_FILE_DIR)$(LINKED_CLASS_ARCHIVES)$frameworkjars:"`$(JAVACONFIG) DefaultClasspath` && \
    cd "$(BRIDGET_FILES_DIR)" && \
    $(JAVA_COMPILER) $(JAVAC_FLAGS) -sourcepath "$(JAVA_SOURCE_PATH)" -classpath "$classpath" -d "$(CLASS_FILE_DIR)" @"$(BRIDGET_DERIVED_JAVA_FILE_LIST:G=)" && \
    /usr/bin/touch "$(1:G=)"
}
actions Bridget.DeriveAndCompileJava.jikes
{
    $(BRIDGET) -java -o "$(BRIDGET_FILES_DIR)" "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" && \
    frameworkjars="" && \
    for i in `echo $(JAVA_FRAMEWORK_JARS)/*.jar $(JAVA_FRAMEWORK_JARS)/*.zip ` ; do if [ -f "$i" ] ; then frameworkjars="$frameworkjars":"$i" ; fi ; done && \
    classpath="$(CLASS_FILE_DIR)$(LINKED_CLASS_ARCHIVES)$frameworkjars:"`$(JAVACONFIG) DefaultClasspath` && \
    cd "$(BRIDGET_FILES_DIR)" && \
    $(JAVA_COMPILER) +E $(JAVAC_FLAGS) -classpath "$classpath" -d "$(CLASS_FILE_DIR)" `cat "$(BRIDGET_DERIVED_JAVA_FILE_LIST:G=)"` && \
    /usr/bin/touch "$(1:G=)"
}

# Bridget.CompileC.UpdateFileList <list update target> <bridget file> generates draft
# and updates definitive list if it is missing or out of date
actions Bridget.UpdateCFileList
{
    $(BRIDGET) -listobjc "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" >> "$(1:G=)Draft" && \
    if [ ! -e "$(1:G=)" ]; then
        cp "$(1:G=)Draft" "$(1:G=)"
    else 
        _file_list_diffs=`diff --brief "$(1:G=)Draft" "$(1:G=)"`
        if [ "x$_file_list_diffs" != "x" ]; then
            cp "$(1:G=)Draft" "$(1:G=)"
        fi
    fi
}
actions Bridget.DeriveAndCompileC
{
    $(BRIDGET) -stub -init -o "$(BRIDGET_FILES_DIR)" "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" && \
    cd "$(BRIDGET_FILES_DIR)" && \
    $(CC) -c $(ARCH_FLAGS) -O -fno-common -no-cpp-precomp -dynamic "$(FLAGS)" $(GLOBAL_CFLAGS) "-I$(DERIVED_PATHS)" "-I$(HEADER_SEARCH_PATHS)" "-I$(JAVA_HEADERS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(TARGET_BUILD_DIR)/$(PUBLIC_HEADER_DIR:G=)" "-I$(TARGET_BUILD_DIR)/$(PRIVATE_HEADER_DIR:G=)" "$(BRIDGET_CFLAGS)" $(PREFIX_HEADER_CFLAGS) `cat "$(BRIDGET_DERIVED_C_FILE_LIST:G=)"` && \
    find "$(BRIDGET_FILES_DIR)" -type f -name '*.o' -print > "$(BRIDGET_FILE_LIST:G=)" && \
    /usr/bin/touch "$(1:G=)"
}

# GenerateVectorLibraryIntermediates <vector stub> <vector object file> : <exports file>
# Generates and compiles vector stub
rule GenerateVectorLibraryIntermediates
{
    DEPENDS $(1) : $(2) ;
    LOCATE on $(2) = $(SOURCE_ROOT) ;
    VECTOR_STUB on $(1) = $(VECTOR_STUB) ;
    VECTOR_OBJECT_FILE on $(1) = $(VECTOR_OBJECT_FILE) ;
    VECTOR_FRAGMENT_NAME on $(1) = $(VECTOR_FRAGMENT_NAME) ;
    DYLIB_INSTALLED_NAME on $(1) = $(DYLIB_INSTALLED_NAME) ;
    DEPENDS $(VECTOR_STUB) : $(DERIVED_FILE_DIR) ;
}
actions GenerateVectorLibraryIntermediates
{
    $(MAKEPSEUDOLIB) $(2:Q) -p -strip -fragname $(VECTOR_FRAGMENT_NAME:Q) -vector $(VECTOR_STUB:Q) -dylibpath "$(DYLIB_INSTALLED_NAME)"
    $(CC) -Wa,-L -c $(ARCH_FLAGS) -O -fno-common -no-cpp-precomp -dynamic "$(FLAGS)" $(GLOBAL_CFLAGS) -o $(VECTOR_OBJECT_FILE:Q) $(VECTOR_STUB:Q)
}

MASTER_INTERFACES default = /AppleInternal/Carbon/interfaces ;
# !!!:cmolick:20010412 Apple internal RC_ settings nonempty in offical builds
INTERFACER_TARGET_UPDATE default = \"$(RC_ProjectName)-$(RC_ProjectSourceVersion)~$(RC_ProjectBuildVersion)\" ;

rule InterfacerHeaders
{
    INTERFACER_CACHE default = $(TEMP_DIR)$(/)InterfacerCache ;
    local BUILD_DIR_AND_SEPARATOR = $(TARGET_BUILD_DIR)$(/) ;
    INTERFACER_HEADERS = $(1:G=InterfacerHeaders) ;
    if $(INTERFACER_TARGET_UPDATE) {
        INTERFACER_HEADER_OPTIONS += -externalHeader $(INTERFACER_TARGET_UPDATE) ;
    }
    FULL_PUBLIC_HEADER_DIR = $(BUILD_DIR_AND_SEPARATOR)$(PUBLIC_HEADER_DIR:G=) ;
    FULL_PUBLIC_HEADER_DIR on $(INTERFACER_HEADERS) = $(FULL_PUBLIC_HEADER_DIR) ;
    FULL_PRIVATE_HEADER_DIR = $(BUILD_DIR_AND_SEPARATOR)$(PRIVATE_HEADER_DIR:G=) ;
    FULL_PRIVATE_HEADER_DIR on $(INTERFACER_HEADERS) = $(FULL_PRIVATE_HEADER_DIR) ;
   # Create symlink to public header dir in versioned frameworks
    if $(PUBLIC_HEADER_LINK)
      && ! $(PUBLIC_HEADER_LINK) in $(PRODUCT_FILES) {
        SymLink $(PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_LINK_PATH) ;
        ProductFile $(PUBLIC_HEADER_LINK) ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
            ASIDE_PUBLIC_HEADER_LINK default = $(PUBLIC_HEADER_LINK:G=aside) ;
            SymLink $(ASIDE_PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_LINK_PATH) ;
            ProductFileAside $(ASIDE_PUBLIC_HEADER_LINK) ;
        }
        NOUPDATE $(PUBLIC_HEADER_LINK) ;
    }
    # Create symlink to private header dir in versioned frameworks
    if $(PRIVATE_HEADER_LINK)
      && ! $(PRIVATE_HEADER_LINK) in $(PRODUCT_FILES) {
        SymLink $(PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_LINK_PATH) ;
        ProductFile $(PRIVATE_HEADER_LINK) ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
            ASIDE_PRIVATE_HEADER_LINK default = $(PRIVATE_HEADER_LINK:G=aside) ;
            SymLink $(ASIDE_PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_LINK_PATH) ;
            ProductFileAside $(ASIDE_PRIVATE_HEADER_LINK) ;
        }
        NOUPDATE $(PRIVATE_HEADER_LINK) ;
    }

    if $(_BUILD_PHASING) = YES {
        BUILD_PHASE_PRODUCTS += $(INTERFACER_HEADERS) ;
    }
    # Create a public header directory
    if ! $(PUBLIC_HEADER_DIR) in $(PRODUCT_FILES) {
        Mkdir $(PUBLIC_HEADER_DIR) ;
        ProductFile $(PUBLIC_HEADER_DIR) ;
        DEPENDS $(INTERFACER_HEADERS) : $(PUBLIC_HEADER_DIR) ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
            ASIDE_PUBLIC_HEADER_DIR default = $(PUBLIC_HEADER_DIR:G=aside) ;
            Mkdir $(ASIDE_PUBLIC_HEADER_DIR) ;
            ProductFileAside $(ASIDE_PUBLIC_HEADER_DIR) ;
        }
    }
    # Create a private header directory
    if ! $(PRIVATE_HEADER_DIR) in $(PRODUCT_FILES) {
        Mkdir $(PRIVATE_HEADER_DIR) ;
        ProductFile $(PRIVATE_HEADER_DIR) ;
        DEPENDS $(INTERFACER_HEADERS) : $(PRIVATE_HEADER_DIR) ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
            ASIDE_PRIVATE_HEADER_DIR default = $(PRIVATE_HEADER_DIR:G=aside) ;
            Mkdir $(ASIDE_PRIVATE_HEADER_DIR) ;
            ProductFileAside $(ASIDE_PRIVATE_HEADER_DIR) ;
        }
    }

       # install .i files if requested
    if $(FRAMEWORK_INTERFACES) {
        INTERFACER_INSTALL_OPTIONS = -frameworkInterfaces $(SRCROOT)$(/)$(FRAMEWORK_INTERFACES)$(/) -installMasterInterfaces $(DSTROOT)/AppleInternal/Carbon/interfaces/ ;
    }

    Interfacer.Headers $(INTERFACER_HEADERS) ;
    # Interfacer headers are required (ideally these should be phase products)
    DEPENDS $(1) : $(INTERFACER_HEADERS) ;
}

actions Interfacer.Headers
{
    $(INTERFACER) -masterInterfaces "$(MASTER_INTERFACES)/" -cacheFolder "$(INTERFACER_CACHE)/" $(INTERFACER_HEADER_OPTIONS) -c -rez -framework "$(1:D=:S=:G=)" -p -generated "c=$(FULL_PUBLIC_HEADER_DIR:G=)/" -generatedPriv "c=$(FULL_PRIVATE_HEADER_DIR:G=)/" -generated "rez=$(FULL_PUBLIC_HEADER_DIR:G=)/" -generatedPriv "rez=$(FULL_PRIVATE_HEADER_DIR:G=)/" $(INTERFACER_INSTALL_OPTIONS)
}

rule InterfacerExportSetsAndGlue
{
    INTERFACER_CACHE default = $(TEMP_DIR)$(/)InterfacerCache ;
    EXPORT_SETS_DIR default = $(DERIVED_FILE_DIR)$(/)ExportSets ;
    UPP_GLUE_DIR default = $(DERIVED_FILE_DIR)$(/)UPPGlue ;
    COMPONENT_GLUE_DIR default = $(DERIVED_FILE_DIR)$(/)ComponentGlue ;
    RAW_GENERATED_EXPORTS_FILE default = $(EXPORT_SETS_DIR)$(/)fw_$(PRODUCT_NAME)_X.exp ;
    RAW_GENERATED_PRIVATE_EXPORTS_FILE default = $(EXPORT_SETS_DIR)$(/)fw_$(PRODUCT_NAME)Priv_X.exp ;
    # !!!:cmolick:20000602 private exports file optional...bad depend?
    PROCESSED_EXPORTS_FILE default = $(DERIVED_FILE_DIR)$(/)$(PRODUCT_NAME).exp ;
    DEPENDS $(RAW_GENERATED_EXPORTS_FILE) : $(DERIVED_FILE_DIR) ;
    DEPENDS $(RAW_GENERATED_PRIVATE_EXPORTS_FILE) : $(DERIVED_FILE_DIR) ;
    DEPENDS $(PROCESSED_EXPORTS_FILE) : $(DERIVED_FILE_DIR) ;
    # object file dir needs to be in place for glue object file list
    # !!!:cmolick:20020105 this dependence appears superfluous
    # DEPENDS $(PROCESSED_EXPORTS_FILE) : $(RAW_GENERATED_EXPORTS_FILE) ;
    DEPENDS $(1) : $(PROCESSED_EXPORTS_FILE) ;
    if $(GENERATE_HEADERS) = YES {
        DEPENDS $(RAW_GENERATED_EXPORTS_FILE) : $(INTERFACER_HEADERS) ;
        DEPENDS $(PROCESSED_EXPORTS_FILE) : $(INTERFACER_HEADERS) ;
    }
    if $(_BUILD_PHASING) = YES {
        BUILD_PHASE_PRODUCTS += $(RAW_GENERATED_EXPORTS_FILE) $(PROCESSED_EXPORTS_FILE) ;
    }
    HEADER_SEARCH_PATHS on $(RAW_GENERATED_EXPORTS_FILE) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(RAW_GENERATED_EXPORTS_FILE) = $(FRAMEWORK_SEARCH_PATHS) ;
    if $(GENERATE_COMPONENT_GLUE) = YES {
        INTERFACER_FLAGS += -componentGlueC ;
        INTERFACER_COMPONENT_GLUE_FLAGS = -generated "componentGlueC=$(COMPONENT_GLUE_DIR)/" -generatedPriv "componentGlueC=$(COMPONENT_GLUE_DIR)/" ;
    }
    for VARIANT in $(BUILD_VARIANTS) {
        DEPENDS $(PROCESSED_EXPORTS_FILE) : $(OBJECT_FILE_DIR_$(VARIANT)) ;
    }
    GLUE_FILE_LIST default = $(TEMP_DIR)$(/)GlueFileList ;
    Interfacer.RawExportSetsAndGlue $(RAW_GENERATED_EXPORTS_FILE) $(GLUE_FILE_LIST) : $(1) ;
    ProductFile $(RAW_GENERATED_EXPORTS_FILE) ;
    ProductFile $(GLUE_FILE_LIST) ;
    ADDITIONAL_EXPORTS_FILE on $(PROCESSED_EXPORTS_FILE) = $(ADDITIONAL_EXPORTS_FILE) ;
    ADDITIONAL_TRADITIONAL_EXPORTS_FILE on $(PROCESSED_EXPORTS_FILE) = $(ADDITIONAL_TRADITIONAL_EXPORTS_FILE) ;
    Interfacer.PrepareExportList $(PROCESSED_EXPORTS_FILE) : $(RAW_GENERATED_EXPORTS_FILE) ;
    ProductFile $(PROCESSED_EXPORTS_FILE) ;
    #!!!:cmolick:200203019 this dependence is necessary to ensure correct order
    DEPENDS $(PROCESSED_EXPORTS_FILE) : $(RAW_GENERATED_EXPORTS_FILE) ;
    EXPORTED_SYMBOLS_FILE default = $(PROCESSED_EXPORTS_FILE) ;
    ProcessFile $(1) : $(EXPORTED_SYMBOLS_FILE) ;
}

actions Interfacer.RawExportSetsAndGlue
# Generates export sets and UPP glue with Interfacer,
# then attempts to compile UPP glue and add resulting
# object files to a list to use at link time.
{
    $(INTERFACER) -masterInterfaces "$(MASTER_INTERFACES)/" -cacheFolder "$(INTERFACER_CACHE)/" -uppGlueC "$(INTERFACER_FLAGS)" -framework "$(2[1]:G=:D=:S=)" -frameworkExports -p -generated "frameworkExports=$(EXPORT_SETS_DIR)/" -generatedPriv "frameworkExports=$(EXPORT_SETS_DIR)/" -generated "uppGlueC=$(UPP_GLUE_DIR)/" -generatedPriv "uppGlueC=$(UPP_GLUE_DIR)/" $(INTERFACER_COMPONENT_GLUE_FLAGS) $(INTERFACER_INSTALL_OPTIONS)
    if [ -e "$(UPP_GLUE_DIR)" ]; then
        _upp_glue_modules=`ls "$(UPP_GLUE_DIR)"`
        if [ ! "$_upp_glue_modules" = x"$_upp_glue_modules" ]; then
            cd "$(UPP_GLUE_DIR)"
            for _upp_glue in *.c ; do
                $(CC) -c $(ARCH_FLAGS) -O -fno-common -no-cpp-precomp -dynamic -Wmost -Wno-four-char-constants -fpascal-strings -fwritable-strings -fexceptions -DCARBON_THRASH=1 -DforCarbon=1 -DACCESSORS_CALLS_ARE_FUNCTIONS=1 -DUSE_INVOKEUPP_C_GLUE=1 "$(FLAGS)" $(GLOBAL_CFLAGS) "-I$(DERIVED_PATHS)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(BUILT_PRODUCTS_DIR)/$(PUBLIC_HEADER_DIR:G=)" "-I$(BUILT_PRODUCTS_DIR)/$(PRIVATE_HEADER_DIR:G=)" $_upp_glue
            done
            find "$(UPP_GLUE_DIR)" -type f -name '*.i.o' -print > "$(GLUE_FILE_LIST)"
        fi
    fi
    if [ -e "$(COMPONENT_GLUE_DIR)" ]; then
        _component_glue_modules=`ls "$(COMPONENT_GLUE_DIR)"`
        if [ ! "$_component_glue_modules" = x"$_component_glue_modules" ]; then
            cd "$(COMPONENT_GLUE_DIR)"
            for _component_glue in *.c ; do
                $(CC) -c $(ARCH_FLAGS) -O -fno-common -no-cpp-precomp -dynamic -Wmost -Wno-four-char-constants -fpascal-strings -fwritable-strings -fexceptions -DCARBON_THRASH=1 -DforCarbon=1 -DACCESSORS_CALLS_ARE_FUNCTIONS=1 -DUSE_INVOKEUPP_C_GLUE=1 "$(FLAGS)" $(GLOBAL_CFLAGS) "-I$(DERIVED_PATHS)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(BUILT_PRODUCTS_DIR)/$(PUBLIC_HEADER_DIR:G=)" "-I$(BUILT_PRODUCTS_DIR)/$(PRIVATE_HEADER_DIR:G=)" $_component_glue
            done
            find "$(COMPONENT_GLUE_DIR)" -type f -name '*.i.o' -print >> "$(GLUE_FILE_LIST)"
        fi
    fi
}

actions Interfacer.PrepareExportList
# Translates PEF-oriented Interfacer export list output into
# nmedit-compatible export lists for use with mach-o.
{
    cat "$(EXPORT_SETS_DIR)$(/)$(PRODUCT_NAME).exp" "$(EXPORT_SETS_DIR)$(/)$(PRODUCT_NAME)Priv.exp" > $(1:Q)
    _additional_exports_file="$(ADDITIONAL_EXPORTS_FILE)"
    if [ "x$_additional_exports_file" != "x" ]; then
        if [ -f "$_additional_exports_file" ]; then
            cat "$_additional_exports_file" >> $(1:Q)
        fi
    fi
    _additional_traditional_exports_file="$(ADDITIONAL_TRADITIONAL_EXPORTS_FILE)"
    if [ "x$_additional_traditional_exports_file" != "x" ]; then
        if [ -f "$_additional_traditional_exports_file" ]; then
            cat "$_additional_traditional_exports_file" |
             grep -v ^\* | grep -v ^# | grep -v ^\$ | sort | uniq -u | sed -e '1,$ s/^/_/' >> "$(1)"
        fi
    fi
}


# Linking, class archive generation, and related operations:
#
# Variables used by linking operations:
# FLAGS.o of target, LDFLAGS, SECTORDER_FLAGS
# LIBRARY_SEARCH_PATHS, FRAMEWORK_SEARCH_PATHS,
# and optionally LINK_FILE_LIST and INIT_ROUTINE

# ClassArchive <archive> : <class file dir>
# Generates an archive that stores class files in the given directory
rule ClassArchive {
    if $(JAVA_ARCHIVE_TYPE) = JAR {
        local JARFLAGS = $(JAVA_JAR_FLAGS) ;
        if $(JAVA_MANIFEST_FILE) {
            DEPENDS $(1) : $(JAVA_MANIFEST_FILE) ;
            JAVA_MANIFEST_FILE on $(1) = $(SOURCE_ROOT)$(/)$(JAVA_MANIFEST_FILE) ;
            JARFLAGS = $(JARFLAGS)m ;
        }
        JARFLAGS = $(JARFLAGS)f ;
        if $(JAVA_ARCHIVE_COMPRESSION) != YES {
            JARFLAGS = $(JARFLAGS)0 ;
        }
        JARFLAGS += -J-Dfile.encoding=UTF8 ;
        JARFLAGS on $(1) = $(JARFLAGS) ;
	CLASS_FILE_DIR on $(1) = $(CLASS_FILE_DIR) ;
        ClassArchive.jarArchive $(1) : $(2) ;
    }
    else {
        if $(JAVA_ARCHIVE_TYPE) = ZIP {
            local ZIPFLAGS = $(JAVA_ZIP_FLAGS) ;
            if $(JAVA_ARCHIVE_COMPRESSION) != YES {
                ZIPFLAGS = $(ZIPFLAGS)0 ;
            }
            ZIPFLAGS on $(1) = $(ZIPFLAGS) ;
	    CLASS_FILE_DIR on $(1) = $(CLASS_FILE_DIR) ;
            ClassArchive.zipArchive $(1) : $(2) ;
        }
    }
}
# Use jar command to generate an archive
# from the class file list after removing "./" from each file path
actions ClassArchive.jarArchive {
    cd $(2:Q) && $(MKDIR) -p $(1:DQ) && $(JAR) $(JARFLAGS:Q) "$(OTHER_JARFLAGS)" $(JAVA_MANIFEST_FILE:Q) $(1:Q) .
}
# Use zip command to generate an archive
# from the class file list after removing "./" from each file path
actions ClassArchive.zipArchive {
    cd $(2:Q) && $(MKDIR) -p $(1:DQ) && $(ZIP) $(ZIPFLAGS:Q) "$(OTHER_ZIPFLAGS)" $(1:Q) .
}

# Unarchive <location> : <archive>
rule Unarchive
{
    _DESTINATION_DIR = $(1:G=) ;
    if ! $(_DESTINATION_DIR) in $(PRODUCT_FILES) {
        Mkdir $(_DESTINATION_DIR) ;
        ProductFile $(_DESTINATION_DIR) ;
    }
    DEPENDS $(1) : $(_DESTINATION_DIR) ;
    DEPENDS $(1) : $(2) ;
    switch $(2:S) {
        case ".jar" : UnarchiveJar $(1) : $(2) ;
        case ".zip" : UnarchiveZip $(1) : $(2) ;
    }
}

# we use unzip to unarchive jars since it's much faster than jar, and we can exclude the manifest file
actions UnarchiveJar
{
    $(UNZIP) -oq $(2:Q) -x META-INF/MANIFEST.MF -d $(1:G=:Q)
}

actions UnarchiveZip
{
    $(UNZIP) -oq $(2:Q) -d $(1:G=:Q)
}

# ProcessSingleObjectLink <executable> : <inputs> : <rule>
# Calls link rule which then calls ProcessLink
# in order to generate a master object file
# which is also used for symbol editing
rule ProcessSingleObjectLink
{
    local OTHER_LINKED_FILES ;
    # Master object file kept in other directory to avoid name conflict

    MASTER_OBJECT_FILE_$(VARIANT) default = $(OBJECT_FILE_DIR_$(VARIANT))$(/)ProjectBuilderMasterObjectFile.o ;
    NonObjectFiles OTHER_LINKED_FILES : $(LINKED_FILES_$(VARIANT)) ;
    MasterObjectFile $(MASTER_OBJECT_FILE_$(VARIANT)) : $(OBJECT_FILES_$(VARIANT)) : $(EXPORTED_SYMBOLS_FILE) ;
    if $(OTHER_LINKED_FILES) = "" {
        OTHER_LINKED_FILES = $(MASTER_OBJECT_FILE_$(VARIANT)) ;
    }
    else {
        OTHER_LINKED_FILES += $(MASTER_OBJECT_FILE_$(VARIANT)) ;
    }
    if $(VECTOR_OBJECT_FILE) {
        OTHER_LINKED_FILES += $(VECTOR_OBJECT_FILE) ;
    }
    $(3) $(INNER_PRODUCT_$(VARIANT)) : $(OTHER_LINKED_FILES) ;
}

# ProcessLinkWithArchitectureSpecificEditing <executable> : <inputs> : <rule>
# !!!:cmolick:20021115 arch-specific editing is no longer used because symbols should uniform on all architectures
rule ProcessLinkWithArchitectureSpecificEditing
{
    for ARCH in $(ARCHS) {
        MASTER_OBJECT_FILE_$(ARCH)_$(VARIANT) default = $(OBJECT_FILE_DIR_$(VARIANT))$(/)ProjectBuilderMasterObjectFile$(ARCH).o ;
        MasterObjectFile $(MASTER_OBJECT_FILE_$(ARCH)_$(VARIANT)) : $(OBJECT_FILES_$(ARCH)_$(VARIANT)) : $(EXPORTED_SYMBOLS_FILE_$(ARCH)) ;
    }
    NonObjectFiles OTHER_LINKED_FILES : $(LINKED_FILES_$(VARIANT)) ;
    for ARCH in $(ARCHS) {
        if $(OTHER_LINKED_FILES) = "" {
            OTHER_LINKED_FILES = $(MASTER_OBJECT_FILE_$(ARCH)_$(VARIANT)) ;
        }
        else {
            OTHER_LINKED_FILES += $(MASTER_OBJECT_FILE_$(ARCH)_$(VARIANT)) ;
        }
    }
    if $(VECTOR_OBJECT_FILE) {
        OTHER_LINKED_FILES += $(VECTOR_OBJECT_FILE) ;
    }
    $(3) $(INNER_PRODUCT_$(VARIANT)) : $(OTHER_LINKED_FILES) ;
}

# ProcessLink <executable> : <inputs> : <rule>
# Processes <inputs> into <rule>.ARGUMENTS for later use by the <rule> rule
# where <inputs> are object files, libraries, frameworks, object file lists,
# and such and where <rule> is one of StaticLibrary, DynamicLibrary, or
# StandaloneExecutable.
rule ProcessLink
{
    local RULE = $(3) ;
    # Link as standalone executable unless another rule is specified
    RULE default = StandaloneExecutable ;
    # Set rule-specific flags such as StandaloneExecutable.FILELIST_FLAG
    # and store the values in local variables
    local FILELIST_FLAG = $($(RULE).FILELIST_FLAG:G=) ;
    local LIBRARY_FLAG = $($(RULE).LIBRARY_FLAG:G=) ;
    local FRAMEWORK_FLAG = $($(RULE).FRAMEWORK_FLAG:G=) ;
    local FILELIST_NOSPACE = $($(RULE).FILELIST_FLAG:G) ;
    local LIBRARY_NOSPACE = $($(RULE).LIBRARY_FLAG:G) ;
    local FRAMEWORK_NOSPACE = $($(RULE).FRAMEWORK_FLAG:G) ;
    local BATCH_OFILES = $($(RULE).BATCH_OFILES) ;
    # The product depends on all of the input files, although
    # library and framework references may not be resolvable.
    DEPENDS $(1) : $(2) ;
    # link depends on file list
    LINK_FILE_LIST_$(VARIANT) = $(FILE_LIST_$(VARIANT)) ;
    DEPENDS $(1) : $(LINK_FILE_LIST_$(VARIANT)) ;
    # Deal with each input file in turn
    local LINKED ;
    local ARGUMENT ;
    for LINKED in $(2) {
        $(RULE).FILES$(LINKED:S) on $(1) += $(LINKED) ;
        switch $(LINKED:BS) {
            case *.o :
                # If $(BATCH_OFILES) is true then object file lists are generated.
                if $(BATCH_OFILES) != NO {
                    ClearFileList $(LINK_FILE_LIST_$(VARIANT)) ;
                    AppendToFileList $(LINK_FILE_LIST_$(VARIANT)) : $(LINKED) ;
                    DEPENDS $(LINK_FILE_LIST_$(VARIANT)) : $(LINKED) ;
                } else {
                    $(RULE).ARGUMENTS on $(1) += $(LINKED) ;
                }
            case *.objects :
                if $(FILELIST_NOSPACE) {
                    ARGUMENT = $(FILELIST_FLAG)$(LINKED) ;
                    NOTFILE $(ARGUMENT) ;
                } else {
                    NOTFILE $(FILELIST_FLAG) ;
                    ARGUMENT = $(FILELIST_FLAG) $(LINKED) ;
                }
                $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
            case lib*.a :
                if $(LIBRARY_FLAG) {
                    LINKED = $(LINKED:A) ;
                }
                NOCARE $(LINKED) ;
                if $(LIBRARY_NOSPACE) {
                    ARGUMENT = $(LIBRARY_FLAG)$(LINKED) ;
                } else {
                    ARGUMENT = $(LIBRARY_FLAG) $(LINKED) ;
                }
                $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
                NOTFILE $(ARGUMENT) ;
            case *.lib :
                NOCARE $(LINKED) ;
                if $(LIBRARY_FLAG) {
                    if $(LIBRARY_NOSPACE) {
                        ARGUMENT = $(LIBRARY_FLAG)$(LINKED:A) ;
                    } else {
                        ARGUMENT = $(LIBRARY_FLAG) $(LINKED:A) ;
                    }
                    $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
                    NOTFILE $(ARGUMENT) ;
                } else {
                    ECHO jam: warning: For target $(1), rule $(RULE) will ignore $(LINKED) ;
                }
            case *.dylib :
                NOCARE $(LINKED) ;
                if $(LIBRARY_FLAG) {
                    if $(LIBRARY_NOSPACE) {
                        ARGUMENT = $(LIBRARY_FLAG)$(LINKED:A) ;
                    } else {
                        ARGUMENT = $(LIBRARY_FLAG) $(LINKED:A) ;
                    }
                    $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
                    NOTFILE $(ARGUMENT) ;
                } else {
                    ECHO jam: warning: For target $(1), rule $(RULE) will ignore $(LINKED) ;
                }
            case *.framework :
                NOCARE $(LINKED) ;
                if $(FRAMEWORK_FLAG) {
                    if $(FRAMEWORK_NOSPACE) {
                        ARGUMENT = $(FRAMEWORK_FLAG)$(LINKED:B) ;
                    } else {
                        ARGUMENT = $(FRAMEWORK_FLAG) $(LINKED:B) ;
                    }
                    $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
                    NOTFILE $(ARGUMENT) ;
                } else {
                    ECHO jam: warning: For target $(1), rule $(RULE) will ignore $(LINKED) ;
                }
	    case *.jar :
		# silently ignore Java archives since they are valid, but not used for native linking
	    case *.zip :
		# silently ignore Java archives since they are valid, but not used for native linking
            case * :
                ECHO Warning: $(RULE): Unknown extension on "$(LINKED:BS)" when linking with $(RULE) ;
        }
    }
    # include any object files compiled from objc generated with bridget
    if $(BRIDGET_FILE_LIST) {
        AppendFileToFileList $(LINK_FILE_LIST_$(VARIANT)) : $(BRIDGET_FILE_LIST) ;
    }
    if $(BATCH_OFILES) != NO {
        $(RULE).LinkUsingFileList $(1) : $(LINK_FILE_LIST_$(VARIANT)) ;
    }
    else {
        $(RULE).Link $(1) ;
    }
}

actions quietly together piecemeal ClearFileList
{
    $(RM) -rf "$(1)"
}

actions quietly together piecemeal AppendToFileList
{
    for file_reference in "$(2)"
    do
        $(ECHO) "$file_reference" >> "$(1)"
    done
}

actions quietly together piecemeal AppendFileToFileList
{
    cat "$(2)" >> "$(1)"
}

# StaticLibrary <library> : <inputs>
# Stores <inputs> in <library> where <inputs> are object files,
# libraries, frameworks, object file lists, and such
rule StaticLibrary
{
    LIBRARY_SEARCH_PATHS on $(1) = $(LIBRARY_SEARCH_PATHS) ;
    ProcessLink $(1) : $(2) : StaticLibrary ;
    FLAGS.o on $(1) = $(LDFLAGS) $(SECTORDER_FLAGS) ;
}
actions together StaticLibrary
{
}
actions quietly together piecemeal StaticLibrary.Link bind StaticLibrary.ARGUMENTS
{
    ( $(LIBTOOL) -o $(1:Q) $(2:Q) "-L$(LIBRARY_SEARCH_PATHS)" "$(StaticLibrary.ARGUMENTS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG) && $(RANLIB) $(1:Q) )
}
actions quietly together piecemeal StaticLibrary.LinkUsingFileList bind StaticLibrary.ARGUMENTS
{
    ( $(LIBTOOL) -o $(1:Q) "-L$(LIBRARY_SEARCH_PATHS)" -filelist $(2:Q) "$(StaticLibrary.ARGUMENTS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG) && $(RANLIB) $(1:Q) )
}
StaticLibrary.FRAMEWORK_FLAG = ;
StaticLibrary.LIBRARY_FLAG = ;
StaticLibrary.BATCH_OFILES default = YES ;

# StandaloneExecutable <executable> : <inputs>
# Links <inputs> to produce <executable>, where <inputs> are objects,
# libraries, frameworks, and such.
rule StandaloneExecutable
{
    ProcessLink $(1) : $(2) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    LIBRARY_SEARCH_PATHS on $(1) = $(LIBRARY_SEARCH_PATHS) ;
    FLAGS.o on $(1) = $(ARCH_FLAGS) $(LDFLAGS) $(SECTORDER_FLAGS) ;
    if $(INIT_ROUTINE) {
        FLAGS.o on $(1) += -init $(INIT_ROUTINE) ;
    }
}
StandaloneExecutable.FILELIST_FLAG = -filelist ;
StandaloneExecutable.FRAMEWORK_FLAG = -framework ;
StandaloneExecutable.LIBRARY_FLAG = <nospace>-l ;
StandaloneExecutable.BATCH_OFILES default = YES ;
actions together StandaloneExecutable
{
}
actions quietly together StandaloneExecutable.Link bind StandaloneExecutable.ARGUMENTS
{
    $(_LD_FOR_LINKING) -o $(1:Q) "-L$(LIBRARY_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG) "$(StandaloneExecutable.ARGUMENTS)"
}
actions quietly together StandaloneExecutable.LinkUsingFileList bind StandaloneExecutable.ARGUMENTS
{
    $(_LD_FOR_LINKING) -o $(1:Q) "-L$(LIBRARY_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" -filelist $(2:Q) "$(FLAGS.o)" $(INSTALLED_NAME_FLAG) "$(StandaloneExecutable.ARGUMENTS)"
}


# DynamicLibrary <library> : <objects> : <libraries>
# Links <objects> and <libraries> to produce <library>, using $(FLAGS.o)
rule DynamicLibrary
{
    LIBRARY_SEARCH_PATHS on $(1) = $(LIBRARY_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    ProcessLink $(1) : $(2) : DynamicLibrary ;
    FLAGS.o on $(1) = $(ARCH_FLAGS) $(LDFLAGS) $(SECTORDER_FLAGS) ;
    if $(INIT_ROUTINE) {
        FLAGS.o on $(1) += -init $(INIT_ROUTINE) ;
    }
}
actions together DynamicLibrary
{
}
actions quietly together DynamicLibrary.Link bind DynamicLibrary.ARGUMENTS DynamicLibrary.DEFFILE
{
    $(_LD_FOR_LINKING) -o $(1:Q) $(DynamicLibrary.DEFFILE_FLAG)"$(DynamicLibrary.DEFFILE)" "-L$(LIBRARY_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "$(DynamicLibrary.ARGUMENTS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG)
}
actions quietly together DynamicLibrary.LinkUsingFileList bind DynamicLibrary.ARGUMENTS DynamicLibrary.DEFFILE
{
    $(_LD_FOR_LINKING) -o $(1:Q) $(DynamicLibrary.DEFFILE_FLAG)"$(DynamicLibrary.DEFFILE)" "-L$(LIBRARY_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" -filelist $(2:Q) "$(DynamicLibrary.ARGUMENTS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG)
}
DynamicLibrary.DEFFILE_FLAG = "-Xlinker -DEF:" ;
DynamicLibrary.FILELIST_FLAG = -filelist ;
DynamicLibrary.FRAMEWORK_FLAG = -framework ;
DynamicLibrary.LIBRARY_FLAG = <nospace>-l ;
DynamicLibrary.BATCH_OFILES default = YES ;

# MasterObjectFile <master object file> : <object files> : <exports file> : [<arch>]
# Merges many object files into one in order to edit
# the list of exported symbols
rule MasterObjectFile
{
    local OBJECT_FILE ;
    if $(4) {
        LINK_FILE_LIST_$(VARIANT) = $(FILE_LIST_$(VARIANT))Prelink_$(4) ;
    }
    else {
        LINK_FILE_LIST_$(VARIANT) = $(FILE_LIST_$(VARIANT))Prelink ;
    }
    # object files must be present before master can be assembled
    DEPENDS $(1) : $(2) ;
    # list object files in a file to limit link line length
    DEPENDS $(1) : $(LINK_FILE_LIST_$(VARIANT)) ;
    ClearFileList $(LINK_FILE_LIST_$(VARIANT)) ;
    for LINKED in $(2) {
        AppendToFileList $(LINK_FILE_LIST_$(VARIANT)) : $(LINKED) ;
        DEPENDS $(LINK_FILE_LIST_$(VARIANT)) : $(LINKED) ;
    }
    if $(KEEP_PRIVATE_EXTERNS) != NO {
        KEEP_PRIVATE_EXTERNS_FLAG on $(1) = -keep_private_externs ;
    }
    if $(GLUE_FILE_LIST) {
        DEPENDS $(LINK_FILE_LIST_$(VARIANT)) : $(GLUE_FILE_LIST) ;
        AppendFileToFileList $(LINK_FILE_LIST_$(VARIANT)) : $(GLUE_FILE_LIST) ;
    }
    PRELINK_FLAGS on $(1) = $(PRELINK_FLAGS) ;
    PRELINK_LIBS on $(1) = $(PRELINK_LIBS) ;
    # !!!:cmolick:20021021 provide an optional way for the target to depend on the PRELINK_LIBS?
    if $(_BUILD_PHASING) = YES {
        BUILD_PHASE_PRODUCTS += $(1) ;
    }
    MasterObjectFile.Combine $(1) : $(LINK_FILE_LIST_$(VARIANT)) ;
    if $(3) {
        INCLUDES $(1) : $(3) ;
        MasterObjectFile.EditExports $(1) : $(3) ;
    }
}
actions MasterObjectFile.Combine
{
    $(_LD_FOR_LINKING) $(ARCH_FLAGS) $(KEEP_PRIVATE_EXTERNS_FLAG) $(GLOBAL_CFLAGS) -L$(LIBRARY_SEARCH_PATHS:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) $(PRELINK_FLAGS:Q) $(WARNING_LDFLAGS) -nostdlib -filelist $(2:Q) -r -o $(1:Q) $(PRELINK_LIBS:Q)
}
actions MasterObjectFile.EditExports
{
    $(NMEDIT) -s $(2:Q) $(1:Q) -o $(1:Q)
}

# EditSymbols <binary> : <symbols file>
# !!!:cmolick:20021022 rule for invoking nmedit needed until exported symbols flags available for linker
rule EditSymbols
{
    DEPENDS $(1) : $(2) ;
}
actions EditSymbols
{
    $(NMEDIT) -s $(2:Q) $(1:Q) -o $(1:Q)
}

# Ranlib <library>
# Ranlib for static library
actions Ranlib
{
    $(RANLIB) $(1:Q)
}

# VersioningSystem_next-cvs <product>
# Handles automatic generation of CVSVersionInfo.txt file for projects that use NeXT CVS-style versioning.
rule VersioningSystem_next-cvs
{
    local VERSION_INFO_FILE ;
    VERSION_INFO_FILE default = $(1:B)_vers.c ;
    # Make sure that the C file containing the version string gets created.
    VersioningSystem_next-cvs.Create $(VERSION_INFO_FILE) : $(1:B) ;
    DerivedFiles $(VERSION_INFO_FILE) ;
    SUPPRESS_PREFIX_HEADER = YES ;
    ProcessFile $(1) : $(VERSION_INFO_FILE) ;
    SUPPRESS_PREFIX_HEADER = NO ;

    # Set up default values for the variables.
    CVS_VERS_FILE default = CVSVersionInfo.txt ;
}
rule VersioningSystem_next-cvs.Create
{
    DEPENDS $(1) : $(CVS_VERS_FILE) ;
}
actions VersioningSystem_next-cvs.Create
{
    versFile="$(CVS_VERS_FILE)"
    awk=/usr/bin/awk
    user=`$awk '/\\$\Id:/ {print $7;}' $versFile`
    timestamp=`$awk '/\\$\Id:/ {print $5 " " $6;}' $versFile`
    fileVers=`$awk '/\\$\Id:/ {print $4;}' $versFile`
    name=`$awk '/^ProjectName:/ {print $2;}' $versFile`
    tag=`$awk '/\\$\Name:/ {print $3;}' $versFile`
    versNum=`$awk '/^ProjectVersion:/ {print $2;}' $versFile`
    proj="$(2:B)"
    clean_proj_name=`echo $proj | sed 's/[^0-9A-Za-z]/_/g'`
    # the keyword name is the current tag and only gets filled in if the files are extracted at
    # that tag. If the tag has a value, then it is a released version, if the tag is '$' then
    # it has no value and is a development version.
    case $tag in '$') vers="$versNum.dev";; *) vers=$versNum;; esac
    q='"'
    vers_str="Project:$proj Version:$vers (Checkpoint by:$user on:$timestamp revision:$fileVers)"
    vers_suffix="$(CURRENT_PROJECT_VERSION_SUFFIX)"
    echo "const char "$clean_proj_name"_VERS_STRING[] = $q@(#)$vers_str$q;" > "$(1)"
    echo "const char "$clean_proj_name"_VERS_NUM[] = $q$vers$vers_suffix$q;" >> "$(1)"
}

# VersioningSystem_apple-generic <product>
# Generates <product>_vers.c to define version symbol
rule VersioningSystem_apple-generic
{
    # Set values to use
    local VERSION_INFO_FILE ;
    VERSION_INFO_FILE default = $(1:B)_vers.c ;

    # variables used need to be defined on the version info file target
    CURRENT_PROJECT_VERSION on $(VERSION_INFO_FILE) = $(CURRENT_PROJECT_VERSION) ;
    VERSION_INFO_EXPORT_DECL on $(VERSION_INFO_FILE) default = $(VERSION_INFO_EXPORT_DECL) ;
    VERSION_INFO_PREFIX on $(VERSION_INFO_FILE) default = $(VERSION_INFO_PREFIX) ;
    VERSION_INFO_SUFFIX on $(VERSION_INFO_FILE) default = $(VERSION_INFO_SUFFIX) ;
    VERSION_INFO_BUILDER on $(VERSION_INFO_FILE) default = $(USER) ;

    # Create versioning code
    VersioningSystem_apple-generic.Create $(VERSION_INFO_FILE) : $(1) ;
    DerivedFiles $(VERSION_INFO_FILE) ;
    SUPPRESS_PREFIX_HEADER = YES ;
    ProcessFile $(1) : $(VERSION_INFO_FILE) ;
    SUPPRESS_PREFIX_HEADER = NO ;
}
actions VersioningSystem_apple-generic.Create
{
    raw_project_name=$(PROJECT:Q)
    project_name=`echo $raw_project_name | sed 's/[^0-9A-Za-z]/_/g'`
    raw_target_name=$(2:BQ)
    target_name=`echo $raw_target_name | sed 's/[^0-9A-Za-z]/_/g'`
    project_vers="$(CURRENT_PROJECT_VERSION)"
    vers_info_export_decl="$(VERSION_INFO_EXPORT_DECL)"
    vers_info_prefix="$(VERSION_INFO_PREFIX)"
    vers_info_suffix="$(VERSION_INFO_SUFFIX)"
    vers_info_builder="$(VERSION_INFO_BUILDER)"
    echo ${vers_info_export_decl} " const unsigned char ${vers_info_prefix}${target_name}VersionString${vers_info_suffix}[] =  \"@(#)PROGRAM:${target_name}  PROJECT:${project_name}-${project_vers}  DEVELOPER:${vers_info_builder}  BUILT:\" __DATE__  \" \" __TIME__ \"\n\";" > "$(1)"
    echo ${vers_info_export_decl} " const double ${vers_info_prefix}${target_name}VersionNumber${vers_info_suffix} = (double)${project_vers};" >> $(1:Q)
}

# KernelModuleGeneratedSource
# Creates a kernel module source stub based on the values
# of MODULE_VERSION, MODULE_START, and MODULE_STOP
rule KernelModuleGeneratedSource
{
    MODULE_INFO_FILE_$(VARIANT) default = $(1:B)_info.c ;
    DerivedFiles $(MODULE_INFO_FILE_$(VARIANT)) ;
    DEPENDS $(MODULE_INFO_FILE_$(VARIANT)) : $(MODULE_INFO_PLIST) ;
    MODULE_VERSION on $(MODULE_INFO_FILE_$(VARIANT)) = $(MODULE_VERSION) ;
    MODULE_NAME on $(MODULE_INFO_FILE_$(VARIANT)) = $(MODULE_NAME) ;
    if $(MODULE_IOKIT) = "YES" {
        MODULE_START on $(MODULE_INFO_FILE_$(VARIANT)) = 0 ;
        MODULE_STOP on $(MODULE_INFO_FILE_$(VARIANT)) = 0 ;
    }
    else {
        if $(MODULE_START) = "" {
            MODULE_START on $(MODULE_INFO_FILE_$(VARIANT)) = 0 ;
        } else {
            MODULE_START on $(MODULE_INFO_FILE_$(VARIANT)) = $(MODULE_START) ;
        }
        if $(MODULE_STOP) = "" {
            MODULE_STOP on $(MODULE_INFO_FILE_$(VARIANT)) = 0 ;
        } else {
            MODULE_STOP on $(MODULE_INFO_FILE_$(VARIANT)) = $(MODULE_STOP) ;
        }
    }
    KernelModuleGeneratedSource.Create $(MODULE_INFO_FILE_$(VARIANT)) ;
    SUPPRESS_PREFIX_HEADER = YES ;
    ProcessFile $(1) : $(MODULE_INFO_FILE_$(VARIANT)) ;
    SUPPRESS_PREFIX_HEADER = NO ;
}
actions KernelModuleGeneratedSource.Create
{
    /bin/echo "#include <mach/mach_types.h>" > $(1:Q)
    /bin/echo " " >> $(1:Q)
    /bin/echo "extern kern_return_t _start(kmod_info_t *ki, void *data);" >> $(1:Q)
    /bin/echo "extern kern_return_t _stop(kmod_info_t *ki, void *data);" >> $(1:Q)
    if [ $(MODULE_START) != 0 ]; then
        /bin/echo "__private_extern__ kern_return_t $(MODULE_START)(kmod_info_t *ki, void *data);" >> $(1:Q)
    fi
    if [ $(MODULE_STOP) != 0 ]; then
        /bin/echo "__private_extern__ kern_return_t $(MODULE_STOP)(kmod_info_t *ki, void *data);" >> $(1:Q)
    fi
    /bin/echo " " >> $(1:Q)
    /bin/echo "KMOD_EXPLICIT_DECL($(MODULE_NAME), \"$(MODULE_VERSION)\", _start, _stop)" >> $(1:Q)
    /bin/echo "__private_extern__ kmod_start_func_t *_realmain = $(MODULE_START);" >> $(1:Q)
    /bin/echo "__private_extern__ kmod_stop_func_t *_antimain = $(MODULE_STOP);" >> $(1:Q)
    /bin/echo "__private_extern__ int _kext_apple_cc = __APPLE_CC__ ;" >> $(1:Q)
}

# GenerateFrameworkStub <framework stub>
# Invokes a custom tool to generate a Mach-O framework executable stub at the specified path
# Also be sure to the FRAMEWORK_INSTALL_NAME variable on the <framework stub>
actions GenerateFrameworkStub
{
    $(MKDIR) -p $(DERIVED_FILE_DIR:Q)
    dummy_class_name=`echo -n $(1:B) | tr -c '[:alnum:]' '_'`
    $(ECHO) "@interface NSFramework_${dummy_class_name}" > $(DERIVED_FILE_DIR:Q)/framework_stub.m
    $(ECHO) "@end" >> $(DERIVED_FILE_DIR:Q)/framework_stub.m
    $(ECHO) "@implementation NSFramework_${dummy_class_name}" >> $(DERIVED_FILE_DIR:Q)/framework_stub.m
    $(ECHO) "@end" >> $(DERIVED_FILE_DIR:Q)/framework_stub.m
    $(CC) -c $(DERIVED_FILE_DIR:Q)/framework_stub.m $(ARCH_FLAGS) -o $(DERIVED_FILE_DIR:Q)/framework_stub.o
    $(_LD_FOR_LINKING) $(ARCH_FLAGS) -dynamiclib $(INSTALLED_NAME_FLAG) $(DYLIB_VERSION_FLAGS:Q) -L$(LIBRARY_SEARCH_PATHS:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) $(DynamicLibrary.ARGUMENTS:Q) $(DERIVED_FILE_DIR:Q)/framework_stub.o -o $(1:Q)
    $(STRIP) $(STRIPFLAGS:Q) $(1:Q)
}
# Copyright (c) 1999-2003 Apple Computer, Inc.
# All rights reserved.

# Define reasonable base locations, to be overridden by default

# Build intermediates go into TEMP_ROOT which defaults to
# build/intermediates in current directory, or OBJROOT if defined
TEMP_ROOT default = $(OBJROOT) ;

# Builds go into the BUILD_ROOT which defaults to
# build/products in current directory, or SYMROOT if defined
BUILD_ROOT default = $(SYMROOT) ;

# Installation root defaults to root, or DSTROOT if defined
INSTALL_ROOT default = $(DSTROOT) ;

# Set initial values for installation information and framework version
_BUILD_PHASING default = YES ;
export INSTALL_OWNER default = $(USER) ;
export INSTALL_GROUP default = $(GROUP) ;
export FRAMEWORK_VERSION default = "A" ;
REMOVE_CVS_FROM_RESOURCES default = YES ;
COPY_PHASE_STRIP default = NO ;
PREBINDING default = YES ;
SET_DIR_MODE_OWNER_GROUP default = YES ;
SET_FILE_MODE_OWNER_GROUP default = NO ;

# Set initial optimization level, debug, and profile settings
export OPTIMIZATION_LEVEL default = 0 ;
export DEBUGGING_SYMBOLS default = YES ;
export PROFILING_CODE default = NO ;

# Default linker warnings
WARNING_LDFLAGS default = -Wl,-no_arch_warnings ;

# Default settings for Java builds
JAVA_ARCHIVE_CLASSES default = YES ;
JAVA_ARCHIVE_TYPE default = JAR ;
JAVA_APP_STUB default = /System/Library/Frameworks/JavaVM.framework/Resources/MacOS/JavaApplicationStub ;
JAVA_JAR_FLAGS default = cv ;
JAVA_SOURCE_SUBDIR default = . ;
JAVA_FRAMEWORK_RESOURCES_DIRS default = Resources ;
export JAVA_FRAMEWORK_JARS default = ;
JAVA_USE_DEPENDENCIES default = YES ;
JAVA_FORCE_FILE_LIST default = NO ;
JAVA_ZIP_FLAGS default = -urg ;

JAVA_COMPILER_DEBUGGING_SYMBOLS default = YES ;
JAVA_COMPILER_DISABLE_WARNINGS default = NO ;
JAVA_COMPILER_DEPRECATED_WARNINGS default = NO ;

# These default flags probably shouldn't be overridden by users.
JAVAC_DEFAULT_FLAGS default = -J-Xms64m -J-XX:NewSize=4M -J-Dfile.encoding=UTF8 ;
JIKES_DEFAULT_FLAGS default = +E +OLDCSO ;

# Default variants and flags
BUILD_VARIANTS default = normal ;
_BUILD_PHASES = ;

# BeginProduct <product>
#
# Initializes the directory and file list variables
#
# Variable references:
# BUILD_ROOT			Base directory for builds
# TARGET_NAME			Name of the target that builds this product
# PRODUCT_NAME			Name of the product that's built
# TEMP_ROOT			Base directory for intermediates
# BASE_PROJECT_HEADER_DIR	Base directory for project headers
# HEADER_SUBDIRECTORY		Path prefix in header #include lines
# INSTALL_ROOT			Base directory for installations
# INSTALL_PATH			Subdirectory where product is installed
# PUBLIC_HEADER_DIR		Location for public headers
#
# Variables set:
# HEADER_SUBDIRECTORY		Base product name
# BUILD_COMPONENTS		List may include: headers, build, source
# OPTIMIZATION_CFLAGS		Optimization flags for C compiles
# OTHER_CPLUSPLUSFLAGS		C++ flags default to C values
# WARNING_CPLUSPLUSFLAGS
# INCLUDED_ARCHS		Architectures intended for this build
# NATIVE_ARCH			Architecture of the build machine
# ARCHS				Architectures used for this build
# ARCH_FLAGS			Architecture flags used for most tools
# SOURCE_DIR			
# BUILD_DIR			Target-specific directory for builds
# TEMP_DIR			For target-specific intermediates
# PROJECT_HEADER_DIR		Project header file directory in $(TEMP_DIR)
# OBJECT_FILE_DIR		Object file directory in $(TEMP_DIR)
# CLASS_FILE_DIR		Class file directory in $(TEMP_DIR)
# FILE_LIST			Base name for lists of files generated
# DERIVED_FILE_DIR		Derived source directory in $(TEMP_DIR)
# INSTALL_DIR			Directory in $(INSTALL_ROOT) for installations
# HEADER_SEARCH_PATHS		Project header directories prepended
# FRAMEWORK_SEARCH_PATHS	Product build root appended
# DERIVED_FILES			Initialized empty
# OBJECT_FILES			Initialized empty
# LINKED_FILES			Initialized empty
# PRODUCT_FILES			Initialized empty
# PRECOMP_TRUSTFILE		List of trusted precompiled headers
#
rule BeginProduct
{
    # target representing the build must be a nonfile pseudotarget
    NOTFILE $(1) ;

    # define the header subdirectory early since we'll use it to
    # compute the project header directory
    HEADER_SUBDIRECTORY = $(1:B) ;

    # the following sequence of tests sets up CC, CPLUSPLUS, LD, and LDPLUSPLUS appropriately,
    # depending on whether we're using GCC 2.95.2, 3.1, 3.3, or 3.5 (either explicitly or implicitly)

    # a hack to detect attempt to use GCC 3, and to set the 'GCC_VERSION' build setting accordingly
    if $(USE_GCC3) = YES  ||  $(USE_GCC2) = NO  ||  $(CC) = "/usr/bin/gcc3" {
        # use either the default gcc version if available or default to 3.1
        if $(_DEFAULT_GCC_VERSION) = 3.1 || $(_DEFAULT_GCC_VERSION) = 3.3 || $(_DEFAULT_GCC_VERSION) = 3.5 {
            GCC_VERSION default = $(_DEFAULT_GCC_VERSION) ;
        }
        else {
            GCC_VERSION default = 3.1 ;
        }
    }
    else if $(USE_GCC2) = YES  ||  $(USE_GCC3) = NO  ||  $(CC) = "/usr/bin/gcc2" {
        GCC_VERSION default = 2.x ;
    }
    else {
        if $(_DEFAULT_GCC_VERSION) = 3.1 || $(_DEFAULT_GCC_VERSION) = 3.3 || $(_DEFAULT_GCC_VERSION) = 3.5 {
            GCC_VERSION default = $(_DEFAULT_GCC_VERSION) ;
        }
        else if $(_DEFAULT_GCC_VERSION) = 2.95.2 {
            GCC_VERSION default = 2.x ;
        }
        else {
            GCC_VERSION default = unknown ;
        }
    }

    # set up CC, CPLUSPLUS, LD, and LDPLUSPLUS appropriately (this logic is temporary, and is
    # expected to be phased out once we have per-build-phase compiler choices)
    if $(GCC_VERSION) = 3.5 {
        CC default = /usr/bin/gcc-3.5 ;
        CPLUSPLUS default = /usr/bin/g++-3.5 ;
    }
    else if $(GCC_VERSION) = 3.3 {
        CC default = /usr/bin/gcc-3.3 ;
        CPLUSPLUS default = /usr/bin/g++-3.3 ;
    }
    else if $(GCC_VERSION) = 3.1 {
        CC default = /usr/bin/gcc3 ;
        CPLUSPLUS default = /usr/bin/g++3 ;
    }
    else if $(GCC_VERSION) = 2.x {
        CC default = /usr/bin/gcc2 ;
        CPLUSPLUS default = /usr/bin/g++2 ;
    }
    else {
        CC default = /usr/bin/cc ;
        CPLUSPLUS default = /usr/bin/c++ ;
    }
    LD default = $(CC) ;
    LDPLUSPLUS default = $(CPLUSPLUS) ;
    _LD_FOR_LINKING = $(LD) ;   # this might get reset to $(LDPLUSPLUS) in the CompileCplusplus rule

    # Set reasonable optimization flags for installs if not already set
    OPTIMIZATION_CFLAGS default = -Os ;
    # precompiled header, C++, Assembly, and Fortran options match C options by default
    OTHER_PRECOMP_CPLUSPLUSFLAGS default = $(OTHER_PRECOMP_CFLAGS) ;
    OTHER_CPLUSPLUSFLAGS default = $(OTHER_CFLAGS) ;
    WARNING_CPLUSPLUSFLAGS default = $(WARNING_CFLAGS) ;
    OTHER_ASFLAGS default = $(OTHER_CFLAGS) ;
    WARNING_ASFLAGS default = $(WARNING_CFLAGS) ;
    OTHER_FFLAGS default = $(OTHER_CFLAGS) ;
    WARNING_FFLAGS default = $(WARNING_CFLAGS) ;
    # Variant flags and suffixes
    for VARIANT in $(BUILD_VARIANTS) {
        if $(VARIANT) = profile {
            OTHER_CFLAGS_$(VARIANT) default = $(OTHER_CFLAGS) -pg ;
            OTHER_ASFLAGS_$(VARIANT) default = $(OTHER_CFLAGS) -pg ;
            OTHER_CPLUSPLUSFLAGS_$(VARIANT) default = $(OTHER_CPLUSPLUSFLAGS) -pg ;
            OTHER_LDFLAGS_$(VARIANT) default = $(OTHER_LDFLAGS) -pg ;
        }
        else {
            OTHER_CFLAGS_$(VARIANT) default = $(OTHER_CFLAGS) ;
            OTHER_ASFLAGS_$(VARIANT) default = $(OTHER_CFLAGS) ;
            OTHER_CPLUSPLUSFLAGS_$(VARIANT) default = $(OTHER_CPLUSPLUSFLAGS) ;
            OTHER_LDFLAGS_$(VARIANT) default = $(OTHER_LDFLAGS) ;
        }
        if $(VARIANT) = normal {
            VARIANT_SUFFIX_$(VARIANT) = "" ;
        }
        else {
            VARIANT_SUFFIX_$(VARIANT) = _$(VARIANT) ;
        }
    }
    # Set up architecture options for product
    INCLUDED_ARCHS default = $(SUPPORTED_ARCHITECTURES) ;
    SUPPORTED_ARCHITECTURE_FLAGS = ;
    ARCHS = ;
    for SUPPORTED_ARCHITECTURE in $(SUPPORTED_ARCHITECTURES) {
        if $($(SUPPORTED_ARCHITECTURE)) = YES
         && ( $(SUPPORTED_ARCHITECTURE) in $(INCLUDED_ARCHS) )
         && ( $(SUPPORTED_ARCHITECTURE) in $(VALID_ARCHS) ) {
            SUPPORTED_ARCHITECTURE_FLAGS += -arch $(SUPPORTED_ARCHITECTURE) ;
            ARCHS += $(SUPPORTED_ARCHITECTURE) ;
        }
    }
    # if somehow no architecture was found, then use the native architecture
    if ! $(ARCHS) {
        $(NATIVE_ARCH) = YES ;
        RC_$(NATIVE_ARCH) = YES ;
        SUPPORTED_ARCHITECTURE_FLAGS += -arch $(NATIVE_ARCH) ;
        ARCHS += $(NATIVE_ARCH) ;
    }

    ARCH_FLAGS default = $(SUPPORTED_ARCHITECTURE_FLAGS) ;
    # Initialize the directory variables
    # SOURCE_DIR is the location of installed sources
    SOURCE_DIR default = $(INSTALL_ROOT) ;
    BUILD_DIR default = $(BUILD_ROOT) ;
    # create base build dir
    Mkdir $(BUILD_DIR) ;
    ProductFile $(BUILD_DIR) ;
    # create active build dir
    if $(TARGET_BUILD_DIR) && ($(TARGET_BUILD_DIR) != $(BUILD_DIR)) {
        Mkdir $(TARGET_BUILD_DIR) ;
    }
    # asides
    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
        SEPARATE_STRIP = YES ;
        ASIDE_DIR default = $(BUILD_ROOT) ;
        Mkdir $(ASIDE_DIR) ;
        ProductFile $(ASIDE_DIR) ;
    }
    # define other important locations
    TEMP_DIR default = $(TEMP_ROOT)$(/)$(PROJECT_NAME).build$(/)$(TARGET_NAME).build ;
    OBJECT_FILE_DIR default = $(TEMP_DIR)$(/)Objects ;
    export CLASS_FILE_DIR default = $(TEMP_DIR)$(/)JavaClasses ;
    for VARIANT in $(BUILD_VARIANTS) {
        OBJECT_FILE_DIR_$(VARIANT) default = $(OBJECT_FILE_DIR)-$(VARIANT) ;
        FILE_LIST_$(VARIANT) default = $(OBJECT_FILE_DIR_$(VARIANT))$(/)LinkFileList ;
        # initialize file lists
        OBJECT_FILES_$(VARIANT) = ;
        LINKED_FILES_$(VARIANT) = ;
    }
    if $(JAVA_ARCHIVE_CLASSES) != YES && ( $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Library ) {
        export PRODUCT_CLASS_FILE_DIR default = $(TARGET_BUILD_DIR)$(/)$(PRODUCT_NAME) ;
    }
    DERIVED_FILE_DIR default = $(TEMP_DIR)$(/)DerivedSources ;
    if $(INSTALL_PATH) {
        INSTALL_DIR default = $(INSTALL_ROOT)$(/)$(INSTALL_PATH) ;
    }
    else {
        INSTALL_DIR default = $(INSTALL_ROOT) ;
    }
    # Initialize the search paths
    if $(TARGET_BUILD_DIR) != $(BUILD_DIR) {
        HEADER_SEARCH_PATHS = $(TARGET_BUILD_DIR)$(/)include $(BUILD_DIR)$(/)include $(HEADER_SEARCH_PATHS) ;
    }
    else {
        HEADER_SEARCH_PATHS = $(BUILD_DIR)$(/)include $(HEADER_SEARCH_PATHS) ;
    }
    FRAMEWORK_SEARCH_PATHS = $(BUILD_ROOT) $(FRAMEWORK_SEARCH_PATHS) ;
    REZ_SEARCH_PATHS default = $(BUILT_PRODUCTS_DIR) $(HEADER_SEARCH_PATHS) ;
    LIBRARY_SEARCH_PATHS = $(BUILD_ROOT) $(LIBRARY_SEARCH_PATHS) ;
    if $(DEPLOYMENT_LOCATION) = YES && $(BUILT_PRODUCTS_DIR) {
        HEADER_SEARCH_PATHS = $(BUILT_PRODUCTS_DIR)$(/)include $(HEADER_SEARCH_PATHS) ;
        FRAMEWORK_SEARCH_PATHS = $(BUILT_PRODUCTS_DIR) $(FRAMEWORK_SEARCH_PATHS) ;
        LIBRARY_SEARCH_PATHS = $(BUILT_PRODUCTS_DIR) $(LIBRARY_SEARCH_PATHS) ;
    }
    # Initialize the file lists
    DERIVED_FILES = ;
    DERIVED_FILE_SOURCES = ;
    PRODUCT_FILES = ;
    PRECOMP_TRUSTFILE default = $(TEMP_DIR)$(/)TrustedPrecomps.txt ;
    # Make symlink to product in products dir,
    # and also set product mode and ownership
    # unless there is no nonempty product name.
    if $(DEPLOYMENT_LOCATION) = YES {
        if $(WRAPPER)
         && $(PRODUCT_TYPE) != Tool
         && $(PRODUCT_TYPE) != Library {
            # Use WRAPPER when defined for bundle product
            _INSTALLED_PRODUCT = $(TARGET_BUILD_DIR)$(/)$(WRAPPER) ;
            _PRODUCT_REFERENCE default = $(BUILT_PRODUCTS_DIR:G=ProductRef)$(/)$(WRAPPER) ;
            #!!!:cmolick:20020517:this may be bad for non-deployment location
            if $(DEPLOYMENT_POSTPROCESSING) = YES {
                SetModeOwnerAndGroup $(_INSTALLED_PRODUCT:G=ModeOwnerGroup) : $(_INSTALLED_PRODUCT) ;
            }
            SymLink $(_PRODUCT_REFERENCE) : $(_INSTALLED_PRODUCT) ;
            DEPENDS $(_PRODUCT_REFERENCE) : $(BUILT_PRODUCTS_DIR) ;
            DEPENDS $(1) : $(_PRODUCT_REFERENCE) ;
        }
        else {
            if $(1:G=) {
                # Use nonempty, ungristed primary target for tool or library product
                _INSTALLED_PRODUCT = $(TARGET_BUILD_DIR)$(/)$(1:G=) ;
                _PRODUCT_REFERENCE default = $(BUILT_PRODUCTS_DIR:G=ProductRef)$(/)$(1:G=) ;
                SymLink $(_PRODUCT_REFERENCE) : $(_INSTALLED_PRODUCT) ;
                DEPENDS $(_PRODUCT_REFERENCE) : $(BUILT_PRODUCTS_DIR) ;
                DEPENDS $(1) : $(_PRODUCT_REFERENCE) ;
            }
        }
    }
    # Set default locations for headers and resources of simple (tool or library) products
    if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Library {
        PUBLIC_HEADER_DIR default = $(TARGET_BUILD_DIR) ;
        PRIVATE_HEADER_DIR default = $(TARGET_BUILD_DIR) ;
        RESOURCE_DIR default = $(TARGET_BUILD_DIR) ;
    }
    # Run the hack script to build debug and profile variants, if appropriate.
    if $(INTERNAL_BUILD_VARIANTS)
     && ( $(RC_JASPER) || $(INTERNAL_BUILD_VARIANTS_ONLY_IN_JASPER) != YES )
     && ( $(ACTION) = build || $(ACTION) = install ) {
        # build variants list should be used only by this call in this case
        _INTERNAL_BUILD_VARIANTS = $(INTERNAL_BUILD_VARIANTS) ;
        INTERNAL_BUILD_VARIANTS = ;
        INTERNAL_BUILD_VARIANTS on $(1) = $(_INTERNAL_BUILD_VARIANTS) ;
        RunVariantHackScript $(1) ;
    }
}

# EndProduct <product>
#
# Creates BUILD_DIR, OBJECT_FILE_DIR, CLASS_FILE_DIR, DERIVED_FILE_DIR,
# and the PROJECT_HEADER_DIR if necessary, then sets up the build action.
rule EndProduct
{
    # Create required directories.  This is done here to allow
    # variables to be overridden before this rule is evaluated.
    for VARIANT in $(BUILD_VARIANTS) {
        Mkdir $(OBJECT_FILE_DIR_$(VARIANT)) ;
        PRODUCT_FILES += $(OBJECT_FILE_DIR_$(VARIANT)) ;
        DEPENDS $(1) : $(OBJECT_FILE_DIR_$(VARIANT)) ;
    }
    if $(DEPLOYMENT_LOCATION) {
        Mkdir $(BUILT_PRODUCTS_DIR) ;
        PRODUCT_FILES += $(BUILT_PRODUCTS_DIR) ;
        DEPENDS $(1) : $(BUILT_PRODUCTS_DIR) ;
    }
    Mkdir $(CLASS_FILE_DIR) ;
    PRODUCT_FILES += $(CLASS_FILE_DIR) ;
    DEPENDS $(1) : $(CLASS_FILE_DIR) ;
    Mkdir $(DERIVED_FILE_DIR) ;
    PRODUCT_FILES += $(DERIVED_FILE_DIR) ;
    DEPENDS $(1) : $(DERIVED_FILE_DIR) ;
    # Set up post-phase processing
    if $(POST_PHASE_PRODUCTS) {
        DEPENDS $(1) : $(POST_PHASE_PRODUCTS) ;
        DEPENDS $(POST_PHASE_PRODUCTS) : $(_BUILD_PHASES) ;
    }
    # Alternative catch-all mechanism to set mode and ownership of files
    # that for some reason require this post build processing.
    # !!!:cmolick:20021025 skip this if action is installhdrs since
    #  it is not relevant in that case and might even be impossible
    if ( $(DEPLOYMENT_POSTPROCESSING) = YES && $(_INSTALLED_PRODUCT) ) {
        DEPENDS $(_INSTALLED_PRODUCT:G=ModeOwnerGroup) : $(PRODUCT_FILES) ;
    }
    if $(DEPLOYMENT_POSTPROCESSING) = YES && $(ACTION) != installhdrs {
    PREVIOUS_PERMISSIONS_TARGET = ;
    for ALTERNATE_PERMISSIONS_FILE in $(ALTERNATE_PERMISSIONS_FILES) {
        ALTERNATE_PERMISSIONS_FILE_PATH = $(INSTALL_DIR)$(/)$(ALTERNATE_PERMISSIONS_FILE) ;
        ALTERNATE_PERMISSIONS_TARGET = $(ALTERNATE_PERMISSIONS_FILE:G=AlternatePermissions) ;
        if $(PREVIOUS_PERMISSIONS_TARGET) {
            DEPENDS $(ALTERNATE_PERMISSIONS_TARGET) : $(PREVIOUS_PERMISSIONS_TARGET) ;
        }
        else {
            if ( $(DEPLOYMENT_POSTPROCESSING) = YES && $(_INSTALLED_PRODUCT) ) {
                DEPENDS $(ALTERNATE_PERMISSIONS_TARGET) : $(_INSTALLED_PRODUCT:G=ModeOwnerGroup) ;
            }
        }
        NOTFILE $(ALTERNATE_PERMISSIONS_TARGET) ;
        DEPENDS $(1) : $(ALTERNATE_PERMISSIONS_TARGET) ;
        DEPENDS $(ALTERNATE_PERMISSIONS_TARGET) : $(_BUILD_PHASES) ;
        if $(ALTERNATE_MODE) {
            INSTALL_MODE_FLAG on $(ALTERNATE_PERMISSIONS_TARGET) = $(ALTERNATE_MODE) ;
        }
        if $(ALTERNATE_OWNER) {
            INSTALL_OWNER on $(ALTERNATE_PERMISSIONS_TARGET) = $(ALTERNATE_OWNER) ;
        }
        if $(ALTERNATE_GROUP) {
            INSTALL_GROUP on $(ALTERNATE_PERMISSIONS_TARGET) = $(ALTERNATE_GROUP) ;
        }
        SetModeOwnerAndGroup $(ALTERNATE_PERMISSIONS_TARGET) : $(ALTERNATE_PERMISSIONS_FILE_PATH) ;
        PREVIOUS_PERMISSIONS_TARGET = $(ALTERNATE_PERMISSIONS_TARGET) ;
    }
    }
    # Define actions for this target
    Actions $(1) ;
}

# BeginWrappedProduct <product>
#
# Sets additional variables required for wrapped products,
# primarily to assign locations within the product wrapper.
# WRAPPER			Local convenience variable
# WRAPPER_SUFFIX		Based on WRAPPER_EXTENSION by default
# RESOURCE_DIR			Base bundle resources location
# APPLESCRIPTS_DIR		Compiled AppleScript files folder
# [PUBLIC|PRIVATE]_HEADER_[DIR|LINK|LINK_PATH] Header folders
# CURRENT_VERSION_[DIR|LINK|LINK_PATH]
# HEADERDOC_DIR			Headerdoc output folder
# PRODUCT_CLASS_FILE_DIR	Defined if JAVA_ARCHIVE_CLASSES	is set
# 
rule BeginWrappedProduct
{
    # define wrapper using appropriate extension and suffix
    if $(WRAPPER_EXTENSION) {
        WRAPPER_SUFFIX = .$(WRAPPER_EXTENSION) ;
    }
    if $(WRAPPER_SUFFIX) {
        WRAPPER = $(1:G=:S=$(WRAPPER_SUFFIX)) ;
    }
    else {
        WRAPPER = $(1:G=) ;
    }
    # set up the basic product variables
    BeginProduct $(1) ;
    # define and create wrapper and make primary nonfile target depend on it
    LOCATE on $(WRAPPER) = $(TARGET_BUILD_DIR) ;
    Mkdir $(WRAPPER) ;
    PRODUCT_FILES += $(WRAPPER) ;
    DEPENDS $(1) : $(WRAPPER) ;
    if $(PRODUCT_TYPE) = Application {
        # Application wrappers
        if $(PURE_JAVA) = YES {
            RESOURCE_DIR default = $(WRAPPER) ;
        }
        else {
            RESOURCE_DIR default = $(WRAPPER)$(/)Contents$(/)Resources ;
        }
        LOCATE on $(RESOURCE_DIR) = $(TARGET_BUILD_DIR) ;
        RESOURCE_LINK = "" ;
        APPLESCRIPTS_DIR default = $(RESOURCE_DIR)$(/)Scripts ;
        LOCATE on $(APPLESCRIPTS_DIR) = $(TARGET_BUILD_DIR) ;
        PUBLIC_HEADER_DIR default = $(WRAPPER)$(/)"Contents"$(/)Headers ;
        LOCATE on $(PUBLIC_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
        PUBLIC_HEADER_LINK default = "" ;
        PRIVATE_HEADER_DIR default = $(WRAPPER)$(/)"Contents"$(/)PrivateHeaders ;
        LOCATE on $(PRIVATE_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
        PRIVATE_HEADER_LINK default = "" ;
        CURRENT_VERSION_DIR default = "" ;
        CURRENT_VERSION_LINK default = "" ;
    } # application wrappers
    else if $(PRODUCT_TYPE) = Framework {
        # Framework wrappers
        RESOURCE_DIR default = $(WRAPPER)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)Resources ;
        LOCATE on $(RESOURCE_DIR) = $(TARGET_BUILD_DIR) ;
        RESOURCE_LINK default = $(WRAPPER)$(/)Resources ;
        LOCATE on $(RESOURCE_LINK) = $(TARGET_BUILD_DIR) ;
        RESOURCE_LINK_PATH default = Versions$(/)Current$(/)Resources ;
        APPLESCRIPTS_DIR default = $(RESOURCE_DIR)$(/)Scripts ;
        LOCATE on $(APPLESCRIPTS_DIR) = $(TARGET_BUILD_DIR) ;
        HAS_PUBLIC_HEADERS = "NO" ;
        PUBLIC_HEADER_DIR default = $(WRAPPER)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)Headers ;
        LOCATE on $(PUBLIC_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
        PUBLIC_HEADER_LINK default = $(WRAPPER)$(/)Headers ;
        LOCATE on $(PUBLIC_HEADER_LINK) = $(TARGET_BUILD_DIR) ;
        PUBLIC_HEADER_LINK_PATH default = Versions$(/)Current$(/)Headers ;
        PRIVATE_HEADER_DIR default = $(WRAPPER)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)PrivateHeaders ;
        LOCATE on $(PRIVATE_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
        PRIVATE_HEADER_LINK default = $(WRAPPER)$(/)PrivateHeaders ;
        LOCATE on $(PRIVATE_HEADER_LINK) = $(TARGET_BUILD_DIR) ;
        PRIVATE_HEADER_LINK_PATH default = Versions$(/)Current$(/)PrivateHeaders ;
        CURRENT_VERSION_DIR default = $(WRAPPER:G=)$(/)Versions$(/)$(FRAMEWORK_VERSION) ;
        LOCATE on $(CURRENT_VERSION_DIR) = $(TARGET_BUILD_DIR) ;
        CURRENT_VERSION_LINK default = $(WRAPPER:G=)$(/)Versions$(/)Current ;
        LOCATE on $(CURRENT_VERSION_LINK) = $(TARGET_BUILD_DIR) ;
        CURRENT_VERSION_LINK_PATH default = Versions$(/)Current ;
        if $(ASIDE_DIR) {
            ASIDE_CURRENT_VERSION_DIR default = $(WRAPPER:G=aside)$(/)Versions$(/)$(FRAMEWORK_VERSION) ;
            ASIDE_CURRENT_VERSION_LINK default = $(WRAPPER:G=aside)$(/)Versions$(/)Current ;
            ASIDE_CURRENT_VERSION_LINK_PATH default = Versions$(/)Current ;
            ASIDE_CURRENT_VERSION_LINK_PATH = $(ASIDE_CURRENT_VERSION_LINK_PATH:G=aside) ;
            Mkdir $(ASIDE_CURRENT_VERSION_DIR) ;
            ProductFileAside $(ASIDE_CURRENT_VERSION_DIR) ;
            DEPENDS $(1) : $(ASIDE_CURRENT_VERSION_DIR) ;
            NOUPDATE $(ASIDE_CURRENT_VERSION_DIR) ;
            SymLink $(ASIDE_CURRENT_VERSION_LINK) : $(FRAMEWORK_VERSION) ;
            ProductFileAside $(ASIDE_CURRENT_VERSION_LINK) ;
            DEPENDS $(1) : $(ASIDE_CURRENT_VERSION_LINK) ;
            DEPENDS $(ASIDE_CURRENT_VERSION_LINK) : $(ASIDE_CURRENT_VERSION_DIR) ;
            NOUPDATE $(ASIDE_CURRENT_VERSION_LINK) ;
        }
        # Create current version directory and link now because
        # they are implicit and needed by almost everything else:
        # Current version dir
        Mkdir $(CURRENT_VERSION_DIR) ;
        ProductFile $(CURRENT_VERSION_DIR) ;
        DEPENDS $(1) : $(CURRENT_VERSION_DIR) ;  # need this or build phase
        NOUPDATE $(CURRENT_VERSION_DIR) ;
        # Current version link
        SymLink $(CURRENT_VERSION_LINK) : $(FRAMEWORK_VERSION) ;
        ProductFile $(CURRENT_VERSION_LINK) ;
        DEPENDS $(1) : $(CURRENT_VERSION_LINK) ;  # need this or build phase
        DEPENDS $(CURRENT_VERSION_LINK) : $(CURRENT_VERSION_DIR) ;
        NOUPDATE $(CURRENT_VERSION_LINK) ;
    } # framework wrappers
    else {
        # Default bundle wrappers
        if $(BUNDLE_STYLE) = SHALLOW {
            # shallow bundles do not have the Contents/Resources folders
            RESOURCE_DIR default = $(WRAPPER) ;
            LOCATE on $(RESOURCE_DIR) = $(TARGET_BUILD_DIR) ;
            APPLESCRIPTS_DIR default = $(WRAPPER)$(/)Scripts ;
            LOCATE on $(APPLESCRIPTS_DIR) = $(TARGET_BUILD_DIR) ;
            PUBLIC_HEADER_DIR default = $(WRAPPER)$(/)Headers ;
            LOCATE on $(PUBLIC_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
            PRIVATE_HEADER_DIR default = $(WRAPPER)$(/)PrivateHeaders ;
            LOCATE on $(PRIVATE_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
        }
        else {
            # else, BUNDLE_STYLE=DEEP bundles do have Contents/Resources folders
            RESOURCE_DIR default = $(WRAPPER)$(/)Contents$(/)Resources ;
            LOCATE on $(RESOURCE_DIR) = $(TARGET_BUILD_DIR) ;
            APPLESCRIPTS_DIR default = $(RESOURCE_DIR)$(/)Scripts ;
            LOCATE on $(APPLESCRIPTS_DIR) = $(TARGET_BUILD_DIR) ;
            PUBLIC_HEADER_DIR default = $(WRAPPER)$(/)Contents$(/)Headers ;
            LOCATE on $(PUBLIC_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
            PRIVATE_HEADER_DIR default = $(WRAPPER)$(/)Contents$(/)PrivateHeaders ;
            LOCATE on $(PRIVATE_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
        }
        RESOURCE_LINK default = "" ;
        PUBLIC_HEADER_LINK default = "" ;
        PRIVATE_HEADER_LINK default = "" ;
        CURRENT_VERSION_DIR default = "" ;
        CURRENT_VERSION_LINK default = "" ;
    } # all bundle layouts
    # define location for optional header documentation generation
    if $(GENERATE_HEADERDOC) = YES && $(RESOURCE_DIR) {
        HEADERDOC_DIR default = $(TARGET_BUILD_DIR)$(/)$(RESOURCE_DIR)$(/)Documentation ;
        Mkdir $(HEADERDOC_DIR) ;
        ProductFile $(HEADERDOC_DIR) ;
    }

    # wrapped products may define a location for unarchived classes
    if $(JAVA_ARCHIVE_CLASSES) != YES {
        export PRODUCT_CLASS_FILE_DIR default = $(TARGET_BUILD_DIR)$(/)$(RESOURCE_DIR)$(/)Java ;
    }
}

# EndWrappedProduct <product>
#
# Sets up additional dependence related to object files.
# Files depended on by object files should be in compile rules,
# and dependence on object files should be in link rules.
rule EndWrappedProduct
{
    # Wrapper touch updates base container directory timestamp
    # This must be conditional on the "build" component,
    # otherwize installhdrs builds with no headers will fail.
    if build in $(BUILD_COMPONENTS) {
        WRAPPER_TOUCH = $(1:G=Touch) ;
        LOCATE on $(WRAPPER_TOUCH) = $(TARGET_BUILD_DIR) ;
        DEPENDS $(WRAPPER_TOUCH) : $(BUILD_PHASE) ;
        DEPENDS $(1) : $(WRAPPER_TOUCH) ;
        Touch $(WRAPPER_TOUCH) ;
    }
    # wrapper logic complete, now handle final build issues
    EndProduct $(1) ;
}
# Copyright (c) 1999-2003 Apple Computer, Inc.
# All rights reserved.

# Rules for target types include Begin and End rules
# for Tool, Library, Bundle, Application, and Framework

TOOL_SUFFIX default = "" ;
rule BeginTool
{
    export PRODUCT_TYPE = Tool ;
    BeginProduct $(1) ;
}

rule EndTool
{
    EndProduct $(1) ;
}

# Library variable names have the form: $(OS)_$(LIBRARY_STYLE)_LIBRARY_$(VARIABLENAME)
MACOS_STATIC_LIBRARY_PREFIX = lib ;
MACOS_STATIC_LIBRARY_SUFFIX = .a ;
MACOS_DYNAMIC_LIBRARY_PREFIX = "" ;
MACOS_DYNAMIC_LIBRARY_SUFFIX = "" ;
DARWIN_STATIC_LIBRARY_PREFIX = lib ;
DARWIN_STATIC_LIBRARY_SUFFIX = .a ;
DARWIN_DYNAMIC_LIBRARY_PREFIX = "" ;
DARWIN_DYNAMIC_LIBRARY_SUFFIX = "" ;
DYNAMIC_LIBRARY_PREFIX = $($(OS)_DYNAMIC_LIBRARY_PREFIX) ;
DYNAMIC_LIBRARY_SUFFIX = $($(OS)_DYNAMIC_LIBRARY_SUFFIX) ;

rule BeginLibrary
{
    # These evaluations here to pick up style from target settings
    LIBRARY_PREFIX = $($(OS)_$(LIBRARY_STYLE)_LIBRARY_PREFIX) ;
    LIBRARY_SUFFIX = $($(OS)_$(LIBRARY_STYLE)_LIBRARY_SUFFIX) ;
    export PRODUCT_TYPE = Library ;
    BeginProduct $(1) ;
}

rule EndLibrary
{
    EndProduct $(1) ;
}

rule BeginBundle
{
    export PRODUCT_TYPE = Bundle ;
    BeginWrappedProduct $(1) ;
}

rule EndBundle
{
    EndWrappedProduct $(1) ;
}

rule BeginApplication
{
    export PRODUCT_TYPE = Application ;
    BeginWrappedProduct $(1) ;
}

rule EndApplication
{
    EndWrappedProduct $(1) ;
}

rule BeginFramework
{
    export PRODUCT_TYPE = Framework ;
    BeginWrappedProduct $(1) ;
}

rule EndFramework
{
    EndWrappedProduct $(1) ;
}
# Copyright (c) 1999-2003 Apple Computer, Inc.
# All rights reserved.

# Variables referenced:
# BUILD_DIR		Location of built product
# RESOURCE_DIR 		Directory for resource files in product
# *_LINK, *_LINK_PATH	Wrapper versioning information
# *_HEADER_DIR		Directories for headers of product
# _INFO_PLIST_FILE_PATH	Path to Info.plist file (if any), generated by PBXCore
# _PKGINFO_FILE_PATH	Path to PkgInfo file (if any), generated by PBXCore
# _VERSION_PLIST_FILE_PATH     Path to version.plist file (if any), generated by PBXCore
# _PBDEVELOPMENT_PLIST_FILE_PATH       Path to pbdevelopment.plist file (if any), generated by PBXCore
# VERSIONING_SYSTEM	Versioning system to use for product
# JAVA_COMPILE_TARGET	Nonfile target representing all java compiles
# REZ_EXECUTABLE	Run Rez directly on executable to produce fork if YES
# PRESERVE_RESOURCES	Files to be recopied with CpMac after install tar copy
# APPLESCRIPTS_DIR	Directory for compiled AppleScripts
#
# Variables set:
# DERIVED_FILES		Intermediate sources
# OBJECT_FILES		Object files produced by compilations
# LINKED_FILES		Files to be used by a link rule
# PRODUCT_FILES		Files that belong in the built product
# INFO_PLIST_FILE	Info.plist file in product wrapper, copied from PRODUCT_SETTINGS_PATH
# PKGINFO_FILE		PkgInfo file in product wrapper, copied from _PKGINFO_FILE_PATH
# HDRRULE, HDRSCAN	Target specific header scanning information
# FLAGS			Target specific compilation flags
# HEADER_SEARCH_PATHS, FRAMEWORK_SEARCH_PATHS	Target specific search paths
#
# Build phase variables:
# BUILD_PHASE		Target for current build phase
# PREVIOUS_BUILD_PHASE	Target for previous build phase
# BUILD_PHASE_PRODUCTS	Products of current build phase
# PHASE_TARGETS		List of all phase targets for conflict checks

# Source and resource handling rules by extension
.h_RULE		= ProcessHeader ;
.nib_RULE	= ProcessResource ;
.rtf_RULE	= ProcessResource ;
.exe_RULE	= ProcessResource ;
.java_RULE	= ProcessUsingJavaCompiler ;
.applescript_RULE	= ProcessAppleScript ;
.c_RULE		= ProcessC ;
.adb_RULE	= ProcessC ; # unsupported
.ads_RULE	= ProcessC ; # unsupported
.C_RULE		= ProcessCplusplus ;
.cc_RULE	= ProcessCplusplus ;
.cp_RULE	= ProcessCplusplus ;
.cpp_RULE	= ProcessCplusplus ;
.CPP_RULE       = ProcessCplusplus ;
.cxx_RULE	= ProcessCplusplus ;
.CXX_RULE	= ProcessCplusplus ;
# !!!:cmolick:20020226 note: .C++ not accepted by c++ compiler driver
.c++_RULE	= ProcessCplusplus ;
.m_RULE		= ProcessC ;
.mm_RULE	= ProcessCplusplus ;
.M_RULE		= ProcessCplusplus ;
.s_RULE		= ProcessAssembly ;
.f_RULE		= ProcessFortran ;
.for_RULE	= ProcessFortran ;
.f77_RULE	= ProcessFortran ;
.f90_RULE	= ProcessFortran ;
.F_RULE		= ProcessFortran ;
.fpp_RULE	= ProcessFortran ;
.exp_RULE	= ProcessExportsFile ;
.defs_RULE	= ProcessUsingMig ;
.mig_RULE	= ProcessUsingMig ;
.l_RULE		= ProcessUsingLex ;
.lm_RULE	= ProcessUsingLex ;
.LM_RULE	= ProcessUsingLex ;
.lmm_RULE	= ProcessUsingLex ;
.lpp_RULE	= ProcessUsingLex ;
.LPP_RULE	= ProcessUsingLex ;
.lxx_RULE	= ProcessUsingLex ;
.LXX_RULE	= ProcessUsingLex ;
.y_RULE		= ProcessUsingYacc ;
.ym_RULE	= ProcessUsingYacc ;
.YM_RULE	= ProcessUsingYacc ;
.ymm_RULE	= ProcessUsingYacc ;
.ypp_RULE	= ProcessUsingYacc ;
.YPP_RULE	= ProcessUsingYacc ;
.yxx_RULE	= ProcessUsingYacc ;
.YXX_RULE	= ProcessUsingYacc ;
.x_RULE		= ProcessUsingRPCGen ;
.jobs_RULE      = ProcessUsingBridget ;
.framework_RULE = ProcessFrameworkOrLibrary ;
.r_RULE		= ProcessRezFile ;
.rsrc_RULE	= ProcessRezFile ;
.RSRC_RULE	= ProcessRezFile ;
.ppob_RULE	= ProcessRezFile ;

# Set the initial list of phase targets to empty
PHASE_TARGETS = ;

# PhaseTarget <phase target variable> <product> <phase name>
# Sets up the given phase target variable based on the target
# and phase name and uses the list of phase targets to attempt
# avoid collisions between targets for phases with the same name.
rule PhaseTarget
{
    local PHASE_SUFFIXES = 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 ;
    local PHASE_TARGET = $(2:G=$(3)) ;
    if $(PHASE_TARGET) in $(PHASE_TARGETS) {
        # attempt differentiation by adding last nonmatching suffix
        for PHASE_SUFFIX in $(PHASE_SUFFIXES) {
            ALTERNATE_PHASE_TARGET = $(2:G=$(3)$(PHASE_SUFFIX)) ;
            if ! $(ALTERNATE_PHASE_TARGET) in $(PHASE_TARGETS) {
                PHASE_TARGET = $(ALTERNATE_PHASE_TARGET) ;
            }
        }
    }
    PHASE_TARGETS += $(PHASE_TARGET) ;
    $(1) = $(PHASE_TARGET) ;
    NOTFILE $(PHASE_TARGET) ;
}

# BuildPhase <phase> <product> <previous phase>
# Set up product (and variant hack) dependence on phase
# and phase dependence on previous phase
# and defines an action to indicate phase completion
rule BuildPhase
{
    # retain a list of all phases
    _BUILD_PHASES += $(1) ;
    # retain name for action echo
    PHASE_NAME on $(1) = $(1:G) ;
    # this build phase depends on the previous phase
    if $(3) {
        DEPENDS $(1) : $(3) ;
    }
    # phase required for parent target
    DEPENDS $(2) : $(1) ;
}
actions BuildPhase
{
    $(ECHO) Completed phase $(PHASE_NAME:Q) for $(1:Q)
}

# DerivedFiles <derived-files>
# Locates derived files in the derived file directory,
# sees the derived paths with the derived file directory if necessary,
# creates derived subpaths and ads them to derived paths as necessary,
# and makes the derived file depend on all derived paths.
rule DerivedFiles
{
    local _DERIVED_FILE ;
    for _DERIVED_FILE in $(1) {
        # !!!:cmolick:20021110 not all these files should be added to DERIVED_FILES
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(_DERIVED_FILE) ;
        }
        # make and depend on containing directory
        LOCATE on $(_DERIVED_FILE) = $(DERIVED_FILE_DIR) ;
        if ! $(DERIVED_PATHS) {
            DERIVED_PATHS = $(DERIVED_FILE_DIR) ;
        }
        local DIR = $(DERIVED_FILE_DIR)$(/)$(_DERIVED_FILE:D) ;
        if ! ( $(DIR) in $(DERIVED_PATHS) ) && ! ( $(DIR)/ in $(DERIVED_PATHS) ) {
            Mkdir $(DIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(DIR) ;
            }
            DERIVED_PATHS += $(DIR) ;
        }
        DEPENDS $(_DERIVED_FILE) : $(DERIVED_PATHS) ;
    }
}

# ProductFile <product-file>
# The product file location is set to BUILD_DIR.
# If the reference and containing directory are not already
# in the list of product files, then they are added.  They also
# become build phase products unless phasing is turned off.
rule ProductFile
{
    LOCATE on $(1) = $(TARGET_BUILD_DIR) ;
    if ! $(1) in $(PRODUCT_FILES) {
        PRODUCT_FILES += $(1) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(1) ;
        }
    }
}

# ProductFileAside <file>
# Same as ProductFile, but default location is ASIDE_DIR.
rule ProductFileAside
{
    LOCATE on $(1) = $(ASIDE_DIR) ;
    if ! $(1) in $(PRODUCT_FILES) {
        PRODUCT_FILES += $(1) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(1) ;
        }
    }
}

# SetModeOwnerAndGroup <nonfile gristed target> : <base target>
# Uses given nonfile gristed target to set mode, owner, and group
# of the base product
rule SetModeOwnerAndGroup
{
    NOTFILE $(1) ;
    LOCATE on $(1) = $(TARGET_BUILD_DIR) ;
    POST_PHASE_PRODUCTS += $(1) ;
    if $(INSTALL_MODE_FLAG) {
        SetMode $(1) : $(2) ;
    }
    if $(INSTALL_OWNER) {
        if $(INSTALL_GROUP) {
            SetOwnerAndGroup $(1) : $(2) ;
        }
        else {
            SetOwner $(1) : $(2) ;
        }
    }
    else if $(INSTALL_GROUP) {
        SetGroup $(1) : $(2) ;
    }
}
actions SetMode
{
     $(CHMOD) -RH $(INSTALL_MODE_FLAG) $(2:G=:Q)
}
actions SetOwner
{
    $(CHOWN) -RH $(INSTALL_OWNER) $(2:G=:Q)
}
actions SetGroup
{
    $(CHOWN) -RH :$(INSTALL_GROUP) $(2:G=:Q)
}
actions SetOwnerAndGroup
{
    $(CHOWN) -RH $(INSTALL_OWNER):$(INSTALL_GROUP) $(2:G=:Q)
}

rule NoOp
{
    if $(_BUILD_PHASING) = YES {
        PhaseTarget BUILD_PHASE : $(1) : NoOp ;
        BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
        PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
    }
}

# ProcessHeaders <product> <headers>
#
# Process individual headers, call Interfacer to generate headers,
# precompile and assemble implicitly included headers as necessary,
# and run headerdoc.
rule ProcessHeaders
{
    if ( headers in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : CopyHeaders ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
#            PREVIOUS_BUILD_PHASE_PRODUCTS = $(BUILD_PHASE_PRODUCTS) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        for FILE in $(2) {
            if $(_BUILD_PHASING) = YES {
                ProcessHeader $(BUILD_PHASE) : $(FILE) ;
            }
            else {
                ProcessHeader $(1) : $(FILE) ;
            }
        }
        
        # conditionally gather documentation generated from headers
        if build in $(BUILD_COMPONENTS) && $(GATHERHEADERDOC) && $(GENERATE_HEADERDOC) = YES && $(HEADERDOC_DIR) && HEADERDOC_TARGETS {
            GATHERED_HEADERDOC_TARGET = masterTOC.html ;
            LOCATE on $(GATHERED_HEADERDOC_TARGET) = $(HEADERDOC_DIR) ;
            DEPENDS $(GATHERED_HEADERDOC_TARGET) : $(HEADERDOC_DIR) ;
            DEPENDS $(GATHERED_HEADERDOC_TARGET) : $(HEADERDOC_TARGETS) ;
            GatheredHeaderDoc $(GATHERED_HEADERDOC_TARGET) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(GATHERED_HEADERDOC_TARGET) ;
            }
        }
    }
    # generate interfacer derived headers
    if headers in $(BUILD_COMPONENTS) && $(GENERATE_HEADERS) = YES {
        InterfacerHeaders $(1) ;
    }
    # Prepare to use prefix file, possibly starting with precompiling
    # Prefix file preparation and precompling is done only when the build action is "build", but not "installhdrs"
    if ( build in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        # The prefix file may be compiled for use with cpp-precomp, PFE, or PCH mechanisms
        if ( $(PREFIX_HEADER) != ""  &&  $(PRECOMPILE_PREFIX_HEADER) = YES ) {
            PFE_FILE_C_DIALECTS default = "c" "objective-c" "c++" "objective-c++" ;
            PRECOMP_DESTINATION_DIR default = $(TEMP_DIR)$(/)PrefixHeaders ;
            Mkdir $(PRECOMP_DESTINATION_DIR) ;
            PRODUCT_FILES += $(PRECOMP_DESTINATION_DIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(PRECOMP_DESTINATION_DIR) ;
            }
            if ( $(GCC_VERSION) = 2.x ) || ( $(GCC_VERSION) = 3.1 && $(USE_GCC3_PFE_SUPPORT) != YES ) {
                # compile prefix file with cpp-precomp
                # create header stub in subfolder of TEMP_DIR
                local PREFIX_HEADER_STUB = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER:BS) ;
                DEPENDS $(PREFIX_HEADER_STUB) : $(PRECOMP_DESTINATION_DIR) ;
                AbsolutePathImportStub $(PREFIX_HEADER_STUB) : $(PREFIX_HEADER) ;
                INCLUDES $(PREFIX_HEADER_STUB) : $(PREFIX_HEADER) ;
                # recompile for C and C++
                if ( "c" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c" in $(PFE_FILE_C_DIALECTS) ) {
                    C_PRECOMP_FILE_DESTINATION_PATH = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER_STUB:BS="-gcc3.p") ;
                    PrecompileHeader $(C_PRECOMP_FILE_DESTINATION_PATH) : $(PREFIX_HEADER_STUB) ;
                    PRODUCT_FILES += $(C_PRECOMP_FILE_DESTINATION_PATH) ;
                    if $(_BUILD_PHASING) = YES {
                        BUILD_PHASE_PRODUCTS += $(C_PRECOMP_FILE_DESTINATION_PATH) ;
                    }
                }
                if ( "c++" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c++" in $(PFE_FILE_C_DIALECTS) ) {
                    CPLUSPLUS_PRECOMP_FILE_DESTINATION_PATH = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER_STUB:BS="-gcc3.pp") ;
                    PrecompileHeader $(CPLUSPLUS_PRECOMP_FILE_DESTINATION_PATH) : $(PREFIX_HEADER_STUB) ;
                    PRODUCT_FILES += $(CPLUSPLUS_PRECOMP_FILE_DESTINATION_PATH) ;
                    if $(_BUILD_PHASING) = YES {
                        BUILD_PHASE_PRODUCTS += $(CPLUSPLUS_PRECOMP_FILE_DESTINATION_PATH) ;
                    }
                }
                # effective prefix header is now header stub
                EFFECTIVE_PREFIX_HEADER = $(PREFIX_HEADER_STUB) ;
                # prepare precompile option using -include
                # set default flags for precompiled prefix header usage
            }
            else {
                if $(GCC_VERSION) = 3.1 && $(USE_GCC3_PFE_SUPPORT) = YES {
                    # prefix file precompiled with PFE support
                    # precompile by dialect
                    for ARCH in $(ARCHS) {
                        EFFECTIVE_PFE_FILE_$(ARCH) = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER:BS="-$(ARCH).pfe") ;
                        if ( "c" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c" in $(PFE_FILE_C_DIALECTS) ) {
                            MakePFEFile $(EFFECTIVE_PFE_FILE_$(ARCH)) : $(PREFIX_HEADER) ;
                        }
                        if ( "c++" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c++" in $(PFE_FILE_C_DIALECTS) ) {
                            MakePFEFile++ $(EFFECTIVE_PFE_FILE_$(ARCH)) : $(PREFIX_HEADER) ;
                        }
                        PRODUCT_FILES += $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
                        if $(_BUILD_PHASING) = YES {
                            BUILD_PHASE_PRODUCTS += $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
                        }
                    }
                    # effective prefix header is empty because no -include flag is passed
                    EFFECTIVE_PREFIX_HEADER = ;
                    # use flag for picking up PFE
                    PREFIX_HEADER_CFLAGS_BASE default = --load-pch ;
                }
                if $(GCC_VERSION) = 3.3 || $(GCC_VERSION) = 3.5 {
                    # prefix file precompiled with PCH support
                    # precompile by dialect
                    for ARCH in $(ARCHS) {
                        EFFECTIVE_PFE_FILE_$(ARCH) = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER:BS="-$(ARCH)").gch ;
                        if ( "c" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c" in $(PFE_FILE_C_DIALECTS) ) {
                            ProcessPCH $(EFFECTIVE_PFE_FILE_$(ARCH)) : $(PREFIX_HEADER) ;
                        }
                        if ( "c++" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c++" in $(PFE_FILE_C_DIALECTS) ) {
                            ProcessPCH++ $(EFFECTIVE_PFE_FILE_$(ARCH)) : $(PREFIX_HEADER) ;
                        }
                        PRODUCT_FILES += $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
                        if $(_BUILD_PHASING) = YES {
                            BUILD_PHASE_PRODUCTS += $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
                        }
                    }
                    # effective prefix header is empty because no -include flag is passed
                    EFFECTIVE_PREFIX_HEADER = ;
                    # use inclusion flag for PCH
                    PREFIX_HEADER_CFLAGS_BASE default = -include ;
                }
            }
        }
        else {
            # In this case there may be a prefix header, but no precompile
            EFFECTIVE_PREFIX_HEADER = $(PREFIX_HEADER) ;
        }
    }
    # phase end logic
    # THIS *MUST* COME *AFTER* ALL OTHER WORK FOR THIS PHASE!!!
    # cmolick:20020213 ideally this should be within action conditionals,
    #  but that is difficult now that there are three disjointed ones,
    #  so checking to see if the build phase is defined is a hack
    #  the problem of bad DEPENDS here on clean for now.
    if $(_BUILD_PHASING) = YES && $(BUILD_PHASE) {
        if $(BUILD_PHASE_PRODUCTS) {
            DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
        }
        PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
    }
}

# ProcessHeader <product or phase> <header>
#
# Generate headerdoc from header as necessary,
# and copy header to subfolders of product as appropriate.
rule ProcessHeader
{
    if source in $(BUILD_COMPONENTS) {
        local HEADER_SOURCE_COPY ;
        local HEADER_SOURCE_DIR ;
        # make directory first if necessary
        if $(2:D) {
            HEADER_SOURCE_DIR = $(SOURCE_DIR)/$(2:D:G=) ;
            Mkdir $(HEADER_SOURCE_DIR) ;
            HEADER_SOURCE_COPY = $(HEADER_SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(HEADER_SOURCE_COPY) : $(HEADER_SOURCE_DIR) ;
        }
        else {
            HEADER_SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(HEADER_SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        Cp $(HEADER_SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(HEADER_SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        # Scan this header to see if it includes other headers.
        if $(ENABLE_HEADER_DEPENDENCIES) != NO && $(DO_HEADER_SCANNING_IN_JAM) = YES {
            HDRRULE on $(2) = ProcessC.HdrRule ;
            HDRSCAN on $(2) = $(HDRPATTERN) ;
        }
        # Set search path for header so dependence analysis will find it
        SEARCH on $(2:D=) += $(2:D) ;

        # conditionally generate documentation from headers
        if $(GENERATE_HEADERDOC) = YES && $(HEADERDOC_DIR) {
            HEADERDOC_TARGET = $(2:B)$(/)toc.html ;
            LOCATE on $(HEADERDOC_TARGET) = $(HEADERDOC_DIR) ;
            HeaderDoc $(HEADERDOC_TARGET) : $(2) ;
            DEPENDS $(HEADERDOC_TARGET) : $(HEADERDOC_DIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(HEADERDOC_TARGET) ;
            }
            HEADERDOC_TARGETS += $(HEADERDOC_TARGET) ;
        }
    }
    local ATTRIBUTES = $($(2)_ATTRIBUTES) ;
    local HEADER_ATTRIBUTE ;
    for HEADER_ATTRIBUTE in $(ATTRIBUTES) {
        switch $(HEADER_ATTRIBUTE) {
            case Project :
                # Define option as valid, but take no action
            case Public :
                HAS_PUBLIC_HEADERS = YES ;
                # Create a public header directory
                if ! $(PUBLIC_HEADER_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(PUBLIC_HEADER_DIR) ;
                    ProductFile $(PUBLIC_HEADER_DIR) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PUBLIC_HEADER_DIR default = $(PUBLIC_HEADER_DIR:G=aside) ;
                        Mkdir $(ASIDE_PUBLIC_HEADER_DIR) ;
                        ProductFileAside $(ASIDE_PUBLIC_HEADER_DIR) ;
                    }
                }
                # Create symlink to public header dir in versioned frameworks
                if $(PUBLIC_HEADER_LINK)
                  && ! $(PUBLIC_HEADER_LINK) in $(PRODUCT_FILES) {
                    SymLink $(PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_LINK_PATH) ;
                    DEPENDS $(PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_DIR) ;
                    ProductFile $(PUBLIC_HEADER_LINK) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PUBLIC_HEADER_LINK default = $(PUBLIC_HEADER_LINK:G=aside) ;
                        SymLink $(ASIDE_PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_LINK_PATH) ;
                        DEPENDS $(ASIDE_PUBLIC_HEADER_LINK) : $(ASIDE_PUBLIC_HEADER_DIR) ;
                        ProductFileAside $(ASIDE_PUBLIC_HEADER_LINK) ;
                    }
                    NOUPDATE $(PUBLIC_HEADER_LINK) ;
                }
                if headers in $(BUILD_COMPONENTS) {
                    if $(PUBLIC_HEADER_DIR) {
                        local HEADER_COPY = $(PUBLIC_HEADER_DIR)$(/)$(2:BS:G=) ;
                        DEPENDS $(HEADER_COPY) : $(2) ;
                        DEPENDS $(HEADER_COPY) : $(PUBLIC_HEADER_DIR) ;
                        PBXCp $(HEADER_COPY) : $(2) ;
                        ProductFile $(HEADER_COPY) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_HEADER_COPY = $(HEADER_COPY:G=aside) ;
                            DEPENDS $(ASIDE_HEADER_COPY) : $(2) ;
                            DEPENDS $(ASIDE_HEADER_COPY) : $(ASIDE_PUBLIC_HEADER_DIR) ;
                            PBXCp $(ASIDE_HEADER_COPY) : $(2) ;
                            ProductFileAside $(ASIDE_HEADER_COPY) ;
                        }
                    }
                    else {
                        ECHO warning: public header $(2) ignored because PUBLIC_HEADER_DIR has no value ;
                    }
                }
            case Private :
                HAS_PRIVATE_HEADERS = YES ;
                # create a private header directory
                if ! $(PRIVATE_HEADER_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(PRIVATE_HEADER_DIR) ;
                    ProductFile $(PRIVATE_HEADER_DIR) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PRIVATE_HEADER_DIR default = $(PRIVATE_HEADER_DIR:G=aside) ;
                        Mkdir $(ASIDE_PRIVATE_HEADER_DIR) ;
                        ProductFileAside $(ASIDE_PRIVATE_HEADER_DIR) ;
                    }
                }
                # accompanying link in versioned frameworks
                if $(PRIVATE_HEADER_LINK)
                  && ! $(PRIVATE_HEADER_LINK) in $(PRODUCT_FILES) {
                    SymLink $(PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_LINK_PATH) ;
                    DEPENDS $(PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_DIR) ;
                    ProductFile $(PRIVATE_HEADER_LINK) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PRIVATE_HEADER_LINK default = $(PRIVATE_HEADER_LINK:G=aside) ;
                        SymLink $(ASIDE_PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_LINK_PATH) ;
                        DEPENDS $(ASIDE_PRIVATE_HEADER_LINK) : $(ASIDE_PRIVATE_HEADER_DIR) ;
                        ProductFileAside $(ASIDE_PRIVATE_HEADER_LINK) ;
                    }
                    NOUPDATE $(PRIVATE_HEADER_LINK) ;
                }
                if headers in $(BUILD_COMPONENTS) {
                    if $(PRIVATE_HEADER_DIR) {
                        local HEADER_COPY = $(PRIVATE_HEADER_DIR)$(/)$(2:BS:G=) ;
                        DEPENDS $(HEADER_COPY) : $(2) ;
                        DEPENDS $(HEADER_COPY) : $(PRIVATE_HEADER_DIR) ;
                        PBXCp $(HEADER_COPY) : $(2) ;
                        ProductFile $(HEADER_COPY) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_HEADER_COPY = $(HEADER_COPY:G=aside) ;
                            DEPENDS $(ASIDE_HEADER_COPY) : $(ASIDE_PRIVATE_HEADER_DIR) ;
                            DEPENDS $(ASIDE_HEADER_COPY) : $(2) ;
                            PBXCp $(ASIDE_HEADER_COPY) : $(2) ;
                            ProductFileAside $(ASIDE_HEADER_COPY) ;
                        }
                    }
                    else {
                        ECHO warning: private header $(2) ignored because PRIVATE_HEADER_DIR has no value ;
                    }
                }
            case * :
                if $(HEADER_ATTRIBUTE) != AbsolutePath {
                    ECHO jam: warning: Ignoring unknown header attribute $(HEADER_ATTRIBUTE) ;
                }
        }
    }
}

rule PrecompileHeader
{
    DEPENDS $(1) : $(2) ;
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_HEADERS) $(KERNEL_HEADERS)/bsd $(KERNEL_FRAMEWORK)/PrivateHeaders ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS_$(ARCH)) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS_$(ARCH)) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) ;    # We must compile with the extension-specific build flags
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    if $(CPP_HEADER_SYMLINKS_DIR) {
        FLAGS on $(1) += "-I$(CPP_HEADER_SYMLINKS_DIR)" ;
    }
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    if $(GCC_VERSION) != 3.3 && $(GCC_VERSION) != 3.5 && $(OS) in MACOS DARWIN {
        FLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
    }
    if $(CPP_HEADERMAP_FILE) {
        FLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
    }
    if $(1:S) = .pp {
            FLAGS on $(1) += -x objective-c++ ;
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(PRECOMP_DESTINATION_DIR)$(/)$(1:DB)-$(ARCH).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    Mkdir $(PRECOMP_DESTINATION_DIR) ;
    DEPENDS $(1) : $(PRECOMP_DESTINATION_DIR) ;
    SEARCH on $(2) = $(SOURCE_ROOT) ;
}
actions PrecompileHeader
{
    $(CC) -precomp -o $(1:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(ARCH_FLAGS) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) -I$(SOURCE_ROOT:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_PRECOMP_CFLAGS)" "$(OTHER_CFLAGS)" $(2:Q)
}

rule MakePFEFile
{
    DEPENDS $(1) : $(2) ;
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_HEADERS) $(KERNEL_HEADERS)/bsd $(KERNEL_FRAMEWORK)/PrivateHeaders ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS_$(ARCH)) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS_$(ARCH)) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) ;    # We must compile with the extension-specific build flags
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    if $(CPP_HEADER_SYMLINKS_DIR) {
        FLAGS on $(1) += "-I$(CPP_HEADER_SYMLINKS_DIR)" ;
    }
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    if $(CPP_HEADERMAP_FILE) {
        FLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(2:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    ARCH on $(1) = $(ARCH) ;
    Mkdir $(PRECOMP_DESTINATION_DIR) ;
    DEPENDS $(1) : $(PRECOMP_DESTINATION_DIR) ;
    SEARCH on $(2) = $(SOURCE_ROOT) ;
}
actions MakePFEFile
{
    for _c_dialect in $(PFE_FILE_C_DIALECTS) ; do if [ ${_c_dialect} == c -o ${_c_dialect} == objective-c ] ; then dummy_file=`mktemp /tmp/.null-XXXXXXXX`; $(CC) -c -x ${_c_dialect} -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) -I$(SOURCE_ROOT:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_PRECOMP_CFLAGS)" "$(OTHER_CFLAGS)" $(2:Q) -o ${dummy_file} --dump-pch $(1:Q) ; exit_code=$? ; rm ${dummy_file} ; if [ ${exit_code} != 0 ] ; then rm -rf $(1:Q) ; exit ${exit_code} ; fi ; fi ; done
}

rule MakePFEFile++
{
    DEPENDS $(1) : $(2) ;
    PER_ARCH_CPLUSPLUSFLAGS_$(ARCH) default = $(PER_ARCH_CFLAGS_$(ARCH)) ;
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_HEADERS) $(KERNEL_HEADERS)/bsd $(KERNEL_FRAMEWORK)/PrivateHeaders ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        KERNEL_COMPILE_OPTIONS += -fapple-kext ;
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS_$(ARCH)) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS_$(ARCH)) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) ;    # We must compile with the extension-specific build flags
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    if $(CPP_HEADER_SYMLINKS_DIR) {
        FLAGS on $(1) += "-I$(CPP_HEADER_SYMLINKS_DIR)" ;
    }
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    if $(CPP_HEADERMAP_FILE) {
        FLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(2:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    ARCH on $(1) = $(ARCH) ;
    Mkdir $(PRECOMP_DESTINATION_DIR) ;
    DEPENDS $(1) : $(PRECOMP_DESTINATION_DIR) ;
    SEARCH on $(2) = $(SOURCE_ROOT) ;
}
actions MakePFEFile++
{
    for _c_dialect in $(PFE_FILE_C_DIALECTS) ; do if [ ${_c_dialect} == c++ -o ${_c_dialect} == objective-c++ ] ; then dummy_file=`mktemp /tmp/.null-XXXXXXXX`; $(CC) -c -x ${_c_dialect} -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) -I$(SOURCE_ROOT:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_PRECOMP_CPLUSPLUSFLAGS)" "$(OTHER_CPLUSPLUSFLAGS)" $(2:Q) -o ${dummy_file} --dump-pch $(1:Q) ; exit_code=$? ; rm ${dummy_file} ; if [ ${exit_code} != 0 ] ; then rm -rf $(1:Q) ; exit ${exit_code} ; fi ; fi ; done
}

rule ProcessPCH
{
    DEPENDS $(1) : $(2) ;
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_HEADERS) $(KERNEL_HEADERS)/bsd $(KERNEL_FRAMEWORK)/PrivateHeaders ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS_$(ARCH)) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS_$(ARCH)) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) ;    # We must compile with the extension-specific build flags
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    if $(CPP_HEADER_SYMLINKS_DIR) {
        FLAGS on $(1) += "-I$(CPP_HEADER_SYMLINKS_DIR)" ;
    }
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    if $(CPP_HEADERMAP_FILE) {
        FLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(2:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    ARCH on $(1) = $(ARCH) ;
    Mkdir $(PRECOMP_DESTINATION_DIR) ;
    DEPENDS $(1) : $(PRECOMP_DESTINATION_DIR) ;
    SEARCH on $(2) = $(SOURCE_ROOT) ;
}
actions ProcessPCH
{
    mkdir -p $(1:Q)
    for _c_dialect in $(PFE_FILE_C_DIALECTS) ; do if [ ${_c_dialect} == c -o ${_c_dialect} == objective-c ] ; then rm -f $(1:Q)$(/)${_c_dialect} ; $(CC) -c -x ${_c_dialect}-header -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) -I$(SOURCE_ROOT:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_PRECOMP_CFLAGS)" "$(OTHER_CFLAGS)" $(2:Q) -o $(1:Q)$(/)${_c_dialect} ; exit_code=$? ; if [ ${exit_code} != 0 ] ; then rm -rf $(1:Q)$(/)${_c_dialect} ; touch $(1:Q) ; exit ${exit_code} ; fi ; fi ; done
}
 
rule ProcessPCH++
{
    DEPENDS $(1) : $(2) ;
    PER_ARCH_CPLUSPLUSFLAGS_$(ARCH) default = $(PER_ARCH_CFLAGS_$(ARCH)) ;
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_HEADERS) $(KERNEL_HEADERS)/bsd $(KERNEL_FRAMEWORK)/PrivateHeaders ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        KERNEL_COMPILE_OPTIONS += -fapple-kext ;
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS_$(ARCH)) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS_$(ARCH)) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) ;    # We must compile with the extension-specific build flags
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    if $(CPP_HEADER_SYMLINKS_DIR) {
        FLAGS on $(1) += "-I$(CPP_HEADER_SYMLINKS_DIR)" ;
    }
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    if $(CPP_HEADERMAP_FILE) {
        FLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(2:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    ARCH on $(1) = $(ARCH) ;
    Mkdir $(PRECOMP_DESTINATION_DIR) ;
    DEPENDS $(1) : $(PRECOMP_DESTINATION_DIR) ;
    SEARCH on $(2) = $(SOURCE_ROOT) ;
}
actions ProcessPCH++
{
    mkdir -p $(1:Q)
    for _c_dialect in $(PFE_FILE_C_DIALECTS) ; do if [ ${_c_dialect} == c++ -o ${_c_dialect} == objective-c++ ] ; then rm -f $(1:Q)$(/)${_c_dialect} ; $(CC) -c -x ${_c_dialect}-header -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) -I$(SOURCE_ROOT:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_PRECOMP_CFLAGS)" "$(OTHER_CPLUSPLUSFLAGS)" $(2:Q) -o $(1:Q)$(/)${_c_dialect} ; exit_code=$? ; if [ ${exit_code} != 0 ] ; then rm -f $(1:Q)$(/)${_c_dialect} ; touch $(1:Q) ; exit ${exit_code} ; fi ; fi ; done
}


# ProcessResources <product> <bundle resources>
#
# Process individual resource files, copy property list settings file,
# and write the package info file if appropriate.
rule ProcessResources
{
    if ( build in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : CopyResources ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        for FILE in $(2) {
            if $(_BUILD_PHASING) = YES {
                ProcessResource $(BUILD_PHASE) : $(FILE) ;
            }
            else {
                ProcessResource $(1) : $(FILE) ;
            }
        }
        # product settings, version settings, and package info written only during build
        if build in $(BUILD_COMPONENTS) {
            # product settings property list
            if $(_INFO_PLIST_FILE_PATH)
             && $(PURE_JAVA) != YES {
                # if available and not pure java
                if $(PRODUCT_TYPE) = Framework {
                    INFO_PLIST_FILE default = $(RESOURCE_DIR)$(/)Info.plist ;
                    if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(RESOURCE_DIR) ;
                        ProductFile $(RESOURCE_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_DIR default = $(RESOURCE_DIR:G=aside) ;
                            Mkdir $(ASIDE_RESOURCE_DIR) ;
                            ProductFileAside $(ASIDE_RESOURCE_DIR) ;
                        }
                    }
                    DEPENDS $(INFO_PLIST_FILE) : $(RESOURCE_DIR) ;
                    if $(RESOURCE_LINK)
                     && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
                        SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                        ProductFile $(RESOURCE_LINK) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_LINK default = $(RESOURCE_LINK:G=aside) ;
                            SymLink $(ASIDE_RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                            ProductFileAside $(ASIDE_RESOURCE_LINK) ;
                        }
                    }
                    DEPENDS $(INFO_PLIST_FILE) : $(RESOURCE_LINK) ;
                }
                else {
                    if $(BUNDLE_STYLE) = SHALLOW {
                        INFO_PLIST_FILE default = $(1:G=)$(/)Info.plist ;
                    }
                    else {
                        INFO_PLIST_FILE default = $(1:G=)$(/)Contents$(/)Info.plist ;
                    }
                    INFO_PLIST_DIR = $(INFO_PLIST_FILE:D) ;
                    if ! $(INFO_PLIST_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(INFO_PLIST_DIR) ;
                        ProductFile $(INFO_PLIST_DIR) ;
                    }
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_INFO_PLIST_DIR default = $(INFO_PLIST_DIR:G=aside) ;
                        if ! $(ASIDE_INFO_PLIST_DIR) in $(PRODUCT_FILES) {
                            Mkdir $(ASIDE_INFO_PLIST_DIR) ;
                            ProductFileAside $(ASIDE_INFO_PLIST_DIR) ;
                        }
                    }
                    DEPENDS $(INFO_PLIST_FILE) : $(INFO_PLIST_DIR) ;
                }
                PBXCp $(INFO_PLIST_FILE) : $(_INFO_PLIST_FILE_PATH) ;
                ProductFile $(INFO_PLIST_FILE) ;
                if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                    ASIDE_INFO_PLIST_FILE default = $(INFO_PLIST_FILE:G=aside) ;
                    DEPENDS $(ASIDE_INFO_PLIST_FILE) : $(ASIDE_INFO_PLIST_DIR) ;
                    PBXCp $(ASIDE_INFO_PLIST_FILE) : $(_INFO_PLIST_FILE_PATH) ;
                    ProductFileAside $(ASIDE_INFO_PLIST_FILE) ;
                }
            }
            # version settings property list
            if $(_VERSION_PLIST_FILE_PATH)
             && $(PURE_JAVA) != YES {
                # if available and not pure java
                if $(PRODUCT_TYPE) = Framework {
	            VERSION_PLIST_FILE default = $(RESOURCE_DIR)$(/)version.plist ;
                    if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(RESOURCE_DIR) ;
                        ProductFile $(RESOURCE_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_DIR default = $(RESOURCE_DIR:G=aside) ;
                            Mkdir $(ASIDE_RESOURCE_DIR) ;
                            ProductFileAside $(ASIDE_RESOURCE_DIR) ;
                        }
                    }
                    DEPENDS $(VERSION_PLIST_FILE) : $(RESOURCE_DIR) ;
                    # create accompanying link in the case of versioned frameworks
                    if $(RESOURCE_LINK)
                     && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
                        SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                        ProductFile $(RESOURCE_LINK) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_LINK default = $(RESOURCE_LINK:G=aside) ;
                            DEPENDS $(ASIDE_RESOURCE_LINK) : $(ASIDE_RESOURCE_DIR) ;
                            SymLink $(ASIDE_RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                            ProductFileAside $(ASIDE_RESOURCE_LINK) ;
                        }
                    }
                    DEPENDS $(VERSION_PLIST_FILE) : $(RESOURCE_LINK) ;
                }
                else {
                    if $(BUNDLE_STYLE) = SHALLOW {
                        VERSION_PLIST_FILE default = $(1:G=)$(/)version.plist ;
                    }
                    else {
                        VERSION_PLIST_FILE default = $(1:G=)$(/)Contents$(/)version.plist ;
                    }
                    VERSION_PLIST_DIR = $(VERSION_PLIST_FILE:D) ;
                    if ! $(VERSION_PLIST_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(VERSION_PLIST_DIR) ;
                        ProductFile $(VERSION_PLIST_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_VERSION_PLIST_DIR default = $(VERSION_PLIST_DIR) ;
                            Mkdir $(ASIDE_VERSION_PLIST_DIR) ;
                            ProductFileAside $(ASIDE_VERSION_PLIST_DIR) ;
                        }
                    }
                    DEPENDS $(VERSION_PLIST_FILE) : $(VERSION_PLIST_DIR) ;
                }
                PBXCp $(VERSION_PLIST_FILE) : $(_VERSION_PLIST_FILE_PATH) ;
                ProductFile $(VERSION_PLIST_FILE) ;
                if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                    ASIDE_VERSION_PLIST_FILE default = $(VERSION_PLIST_FILE:G=aside) ;
                    Cp $(ASIDE_VERSION_PLIST_FILE) : $(_VERSION_PLIST_FILE_PATH) ;
                    DEPENDS $(ASIDE_VERSION_PLIST_FILE) : $(ASIDE_VERSION_PLIST_DIR) ;
                    ProductFileAside $(ASIDE_VERSION_PLIST_FILE) ;
                }
            }
            # Copy development settings property list unless using deployment locations
            if $(DEVELOPMENT_SETTINGS_PATH)
             && $(PURE_JAVA) != YES && $(DEPLOYMENT_LOCATION) != YES {
                # if available and not pure java
                if $(PRODUCT_TYPE) = Framework {
	            DEVELOPMENT_PLIST_FILE default = $(RESOURCE_DIR)$(/)pbdevelopment.plist ;
                    if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(RESOURCE_DIR) ;
                        ProductFile $(RESOURCE_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_DIR default = $(RESOURCE_DIR:G=aside) ;
                            Mkdir $(ASIDE_RESOURCE_DIR) ;
                            ProductFileAsides $(ASIDE_RESOURCE_DIR) ;
                        }
                    }
                    DEPENDS $(DEVELOPMENT_PLIST_FILE) : $(RESOURCE_DIR) ;
                    # create accompanying link in the case of versioned frameworks
                    if $(RESOURCE_LINK)
                      && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
                        SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                        ProductFile $(RESOURCE_LINK) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_LINK default = $(RESOURCE_LINK:G=aside) ;
                            SymLink $(ASIDE_RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                            DEPENDS $(ASIDE_RESOURCE_LINK) : $(ASIDE_RESOURCE_DIR) ;
                            ProductFileAside $(ASIDE_RESOURCE_LINK) ;
                        }
                    }
                    DEPENDS $(DEVELOPMENT_PLIST_FILE) : $(RESOURCE_LINK) ;
                }
                else {
                    if $(BUNDLE_STYLE) = SHALLOW {
                        DEVELOPMENT_PLIST_FILE default = $(1:G=)$(/)pbdevelopment.plist ;
                    }
                    else {
                        DEVELOPMENT_PLIST_FILE default = $(1:G=)$(/)Contents$(/)pbdevelopment.plist ;
                    }
                    DEVELOPMENT_PLIST_DIR = $(DEVELOPMENT_PLIST_FILE:D) ;
                    if ! $(DEVELOPMENT_PLIST_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(DEVELOPMENT_PLIST_DIR) ;
                        ProductFile $(DEVELOPMENT_PLIST_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_DEVELOPMENT_PLIST_DIR default = $(DEVELOPMENT_PLIST_DIR:G=aside) ;
                            Mkdir $(ASIDE_DEVELOPMENT_PLIST_DIR) ;
                            ProductFileAsides $(ASIDE_DEVELOPMENT_PLIST) ;
                        }
                    }
                    DEPENDS $(DEVELOPMENT_PLIST_FILE) : $(DEVELOPMENT_PLIST_DIR) ;
                }
                PBXCp $(DEVELOPMENT_PLIST_FILE) : $(DEVELOPMENT_SETTINGS_PATH) ;
                ProductFile $(DEVELOPMENT_PLIST_FILE) ;
                if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                    ASIDE_DEVELOPMENT_PLIST_FILE default = $(DEVELOPMENT_PLIST_FILE:G=aside) ;
                    PBXCp $(ASIDE_DEVELOPMENT_PLIST_FILE) : $(DEVELOPMENT_SETTINGS_PATH) ;
                    DEPENDS $(ASIDE_DEVELOPMENT_PLIST_FILE) : $(DEVELOPMENT_PLIST_DIR) ;
                    ProductFileAside $(ASIDE_DEVELOPMENT_PLIST_FILE) ;
                }
            }
            # Write package info file with type and creator if available
            # and if not framework or oldest layout or pure java
            if $(_PKGINFO_FILE_PATH)
             && ( $(PRODUCT_TYPE) != Framework
             && $(PRODUCT_TYPE) != Bundle
             && $(PURE_JAVA) != YES || $(GENERATE_PKGINFO_FILE) = YES ) {
                if $(BUNDLE_STYLE) = SHALLOW || $(PRODUCT_TYPE) = Framework {
                    PKGINFO_FILE default = $(1:G=)$(/)PkgInfo ;
                }
                else {
                    PKGINFO_FILE default = $(1:G=)$(/)Contents$(/)PkgInfo ;
                }
                PKGINFO_DIR = $(PKGINFO_FILE:D) ;
                if ! $(PKGINFO_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(PKGINFO_DIR) ;
                    ProductFile $(PKGINFO_DIR) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PKGINFO_DIR default = $(PKGINFO_DIR:G=aside) ;
                        Mkdir $(ASIDE_PKGINFO_DIR) ;
                        ProductFileAside $(ASIDE_PKGINFO_DIR) ;
                    }
                }
                DEPENDS $(PKGINFO_FILE) : $(PKGINFO_DIR) ;
                PBXCp $(PKGINFO_FILE) : $(_PKGINFO_FILE_PATH) ;
                ProductFile $(PKGINFO_FILE) ;
                if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                    ASIDE_PKGINFO_FILE default = $(PKGINFO_FILE:G=aside) ;
                    DEPENDS $(ASIDE_PKGINFO_FILE) : $(ASIDE_PKGINFO_DIR) ;
                    PBXCp $(ASIDE_PKGINFO_FILE) : $(_PKGINFO_FILE_PATH) ;
                    ProductFileAside $(ASIDE_PKGINFO_FILE) ;
                }
            }
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

# ProcessResource <product or phase> <bundle resource>
#
# Copies resources to nonlocalized or localized folders as appropriate
rule ProcessResource
{
    if source in $(BUILD_COMPONENTS) {
        local RESOURCE_SOURCE_COPY ;
        local RESOURCE_SOURCE_DIR ;
        # make directory first if necessary
        if $(2:D) {
            RESOURCE_SOURCE_DIR = $(SOURCE_DIR)/$(2:D:G=) ;
            Mkdir $(RESOURCE_SOURCE_DIR) ;
            RESOURCE_SOURCE_COPY = $(RESOURCE_SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(RESOURCE_SOURCE_COPY) : $(RESOURCE_SOURCE_DIR) ;
        }
        else {
            RESOURCE_SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(RESOURCE_SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        # copy resource to source location
        Cp $(RESOURCE_SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(RESOURCE_SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        local REGION = $($(2)_REGION) ;
        local SPECIFIC_REGION ;
        # resource directory must exist
        if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
            Mkdir $(RESOURCE_DIR) ;
            ProductFile $(RESOURCE_DIR) ;
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_RESOURCE_DIR default = $(RESOURCE_DIR:G=aside) ;
                Mkdir $(ASIDE_RESOURCE_DIR) ;
                ProductFileAside $(ASIDE_RESOURCE_DIR) ;
            }
        }
        # create accompanying link in the case of versioned frameworks
        if $(RESOURCE_LINK)
         && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
            SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
            ProductFile $(RESOURCE_LINK) ;
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_RESOURCE_LINK default = $(RESOURCE_LINK:G=aside) ;
                SymLink $(ASIDE_RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                DEPENDS $(ASIDE_RESOURCE_LINK) : $(ASIDE_RESOURCE_DIR) ;
                ProductFileAside $(ASIDE_RESOURCE_LINK) ;
            }
        }
        if ! $(REGION) {
            # non-localized resource
            local NONLOCALIZED_RESOURCE_DIR NONLOCALIZED_RESOURCE ;
            NONLOCALIZED_RESOURCE_DIR = $(RESOURCE_DIR) ;
            if ! $(NONLOCALIZED_RESOURCE_DIR) in $(PRODUCT_FILES) {
                Mkdir $(NONLOCALIZED_RESOURCE_DIR) ;
                ProductFile $(NONLOCALIZED_RESOURCE_DIR) ;
            }
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_NONLOCALIZED_RESOURCE_DIR = $(NONLOCALIZED_RESOURCE_DIR:G=aside) ;
                if ! $(ASIDE_NONLOCALIZED_RESOURCE_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(ASIDE_NONLOCALIZED_RESOURCE_DIR) ;
                    ProductFileAside $(ASIDE_NONLOCALIZED_RESOURCE_DIR) ;
                }
            }
            NONLOCALIZED_RESOURCE = $(NONLOCALIZED_RESOURCE_DIR)$(/)$(2:BS) ;
            DEPENDS $(NONLOCALIZED_RESOURCE) : $(NONLOCALIZED_RESOURCE_DIR) ;
            DEPENDS $(NONLOCALIZED_RESOURCE) : $(2) ;
            PBXCp $(NONLOCALIZED_RESOURCE) : $(2) ;
            ProductFile $(NONLOCALIZED_RESOURCE) ;
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_NONLOCALIZED_RESOURCE = $(NONLOCALIZED_RESOURCE:G=aside) ;
                DEPENDS $(ASIDE_NONLOCALIZED_RESOURCE) : $(2) ;
                DEPENDS $(ASIDE_NONLOCALIZED_RESOURCE) : $(ASIDE_NONLOCALIZED_RESOURCE_DIR) ;
                PBXCp $(ASIDE_NONLOCALIZED_RESOURCE) : $(2) ;
                ProductFileAside $(ASIDE_NONLOCALIZED_RESOURCE) ;
            }
        } else for SPECIFIC_REGION in $(REGION) {
            # for each localization of a resource (only one ever expected)
            local LOCALIZED_RESOURCE_DIR LOCALIZED_RESOURCE ;
            LOCALIZED_RESOURCE_DIR = $(RESOURCE_DIR)$(/)$(SPECIFIC_REGION:S=.lproj) ;
            # localized resource directory must exist
            if ! $(LOCALIZED_RESOURCE_DIR) in $(PRODUCT_FILES) {
                Mkdir $(LOCALIZED_RESOURCE_DIR) ;
                ProductFile $(LOCALIZED_RESOURCE_DIR) ;
            }
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_LOCALIZED_RESOURCE_DIR = $(LOCALIZED_RESOURCE_DIR:G=aside) ;
                if ! $(ASIDE_LOCALIZED_RESOURCE_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(ASIDE_LOCALIZED_RESOURCE_DIR) ;
                    ProductFileAside $(ASIDE_LOCALIZED_RESOURCE_DIR) ;
                }
            }
            LOCALIZED_RESOURCE = $(LOCALIZED_RESOURCE_DIR)$(/)$(2:BS) ;
            DEPENDS $(LOCALIZED_RESOURCE) : $(2) ;
            DEPENDS $(LOCALIZED_RESOURCE) : $(LOCALIZED_RESOURCE_DIR) ;
            PBXCp $(LOCALIZED_RESOURCE) : $(2) ;
            ProductFile $(LOCALIZED_RESOURCE) ;
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_LOCALIZED_RESOURCE = $(LOCALIZED_RESOURCE:G=aside) ;
                DEPENDS $(ASIDE_LOCALIZED_RESOURCE) : $(2) ;
                DEPENDS $(ASIDE_LOCALIZED_RESOURCE) : $(ASIDE_LOCALIZED_RESOURCE_DIR) ;
                PBXCp $(ASIDE_LOCALIZED_RESOURCE) : $(2) ;
                ProductFileAside $(ASIDE_LOCALIZED_RESOURCE) ;
            }
        }
    }
}

actions CopyProjectFiles
{
    if [ -d $(2:Q) ]; then
        $(CP) -pRP $(2:Q) $(1:Q)
    elif [ -d $(2:S=.pbxproj:Q) ]; then
        $(CP) -pRP $(2:S=.pbxproj:Q) $(1:Q)
    fi
}

# ProcessSources <product> <source files>
#
# Process individual source files and generate versioning stub,
# kernel module stub, and use Interfacer to make exports and glue
rule ProcessSources
{
    if build in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : DeriveAndCompileSources ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        # copy project files if copying source
        if source in $(BUILD_COMPONENTS) {
            local PROJECT_FILES = $(SOURCE_ROOT)/$(PROJECT).pbproj ;
            local LEGACY_PROJECT_FILES = $(SOURCE_ROOT)/$(PROJECT).pbxproj ;
            local PROJECT_FILES_COPY = $(INSTALL_ROOT)/$(PROJECT).pbproj ;
            CopyProjectFiles $(PROJECT_FILES_COPY) : $(PROJECT_FILES) : $(LEGACY_PROJECT_FILES) ;
            DEPENDS $(PROJECT_FILES_COPY) : $(INSTALL_ROOT) ;
            Mkdir $(INSTALL_ROOT) ;
            DEPENDS $(PROJECT_FILES_COPY) : $(PROJECT_FILES) ;
            NOCARE $(PROJECT_FILES) ;
            DEPENDS $(PROJECT_FILES_COPY) : $(LEGACY_PROJECT_FILES) ;
            NOCARE $(LEGACY_PROJECT_FILES) ;
            BUILD_PHASE_PRODUCTS += $(PROJECT_FILES_COPY) ;
        }
        for FILE in $(2) {
            if $(_BUILD_PHASING) = YES {
                ProcessSource $(BUILD_PHASE) : $(FILE) ;
            }
            else {
                ProcessSource $(1) : $(FILE) ;
            }
        }
        # any build component implies handling: header cloning, versioning,
        # kernel module generation, and interfacer usage
        if build in $(BUILD_COMPONENTS) {
            # generate versioning system derived sources
            if $(VERSIONING_SYSTEM) {
                local RULE = VersioningSystem_$(VERSIONING_SYSTEM) ;
                $(RULE) $(1) ;
            }
            # generate kernel module or extension info source
            if $(KERNEL_MODULE) = YES {
                KernelModuleGeneratedSource $(1) ;
            }
            # generate interfacer derived sources
            if $(GENERATE_EXPORT_SETS_AND_GLUE) = YES {
                InterfacerExportSetsAndGlue $(1) ;
            }
        }
        # compilation depends on derivation
        # !!!:cmolick:20021108 this bloats most rebuilds
        for VARIANT in $(BUILD_VARIANTS) {
            if $(OBJECT_FILES_$(VARIANT)) && $(DERIVED_FILES) {
                DEPENDS $(OBJECT_FILES_$(VARIANT)) : $(DERIVED_FILES) ;
            }
        }
        # end of phase logic
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
                # product reference link must be in place before any compiles
                if $(PRODUCT_REFERENCE) {
                    DEPENDS $(BUILD_PHASE_PRODUCTS) : $(PRODUCT_REFERENCE) ;
                }
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

# ProcessSource <product> <source file>
#
# Call ProcessFile to process a source file with the correct
# extension-specific rule, and start header scanning.
rule ProcessSource
{
    # scan non-Java for header file references in any source
    if $(2:S) != ".java" {
        if $(ENABLE_HEADER_DEPENDENCIES) != NO && $(DO_HEADER_SCANNING_IN_JAM) = YES {
            HDRRULE on $(2) = ProcessC.HdrRule ;
            HDRSCAN on $(2) = $(HDRPATTERN) ;
        }
    }
    ProcessFile $(1) : $(2) ;
}

rule ProcessFiles
{
    local FILE ;
    for FILE in $(2) {
        ProcessFile $(1) : $(FILE) ;
    }
}

rule ProcessFile
{
    local SOURCE_COPY ;
    local SOURCE_SUBDIR ;
    if source in $(BUILD_COMPONENTS) {
        # copy to source location
        # make directory first if necessary
        if $(2:D) {
            SOURCE_SUBDIR = $(SOURCE_DIR)/$(2:D:G=) ;
            Mkdir $(SOURCE_SUBDIR) ;
            SOURCE_COPY = $(SOURCE_SUBDIR)/$(2:D=:G=) ;
            DEPENDS $(SOURCE_COPY) : $(SOURCE_SUBDIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(SOURCE_SUBDIR) ;
            }
        }
        else {
            SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        Cp $(SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        # process file with rule based on the file suffix
        local EXCLUDED_OSS = $($(2)_EXCLUDED_OSS) ;
        local INCLUDED_OSS = $($(2)_INCLUDED_OSS) ;
        local RULE = $($(2:S)_RULE) ;

        if $(EXCLUDED_OSS) && ( $(OS) in $(EXCLUDED_OSS) ) {
            # do nothing -- file excluded from build
        } else if $(INCLUDED_OSS) && ! ( $(OS) in $(INCLUDED_OSS) ) {
            # do nothing -- file excluded from build
        } else if $(RULE) {
            $(RULE) $(1) : $(2) ;
        } else {
            ECHO jam: warning: no rule for file $(2) ;
        }
    }
}

# ProcessFrameworksAndLibraries <product> <linked files>
#
# Link object files and/or archive classes
rule ProcessFrameworksAndLibraries
{
    if ( build in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : LinkWithFrameworksAndLibraries ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = $(INNER_PRODUCT) ;
        }
        for VARIANT in $(BUILD_VARIANTS) {
	# add to linked files, including java .jar files even when there are no native object files!
        # This was never questioned, but the long comment was added after this
        # step was repeatedly moved outside this block by integration errors.
	LINKED_FILES_$(VARIANT) += $(2) ;

        # only link if there are object files
        if $(OBJECT_FILES_$(VARIANT)) {
            if ! ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC ) {
                SINGLE_MODULE default = YES ;
            }
            # define products
            if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Library {
                # simple product
                INNER_PRODUCT default = $(1:G=) ;
                INNER_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT)$(VARIANT_SUFFIX_$(VARIANT)) ;
                INNER_PRODUCT_LINK_$(VARIANT) default = ;
                ProductFile $(INNER_PRODUCT_$(VARIANT)) ;
                if $(DEPLOYMENT_POSTPROCESSING) = YES {
                    SetModeOwnerAndGroup $(INNER_PRODUCT_$(VARIANT):G=ModeOwnerGroup) : $(INNER_PRODUCT_$(VARIANT)) ;
                }
            }
            else {
                if $(PRODUCT_TYPE) = Framework {
                    # versioned bundle
                    INNER_PRODUCT default = $(1:G=)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)$(1:BG=) ;
                    INNER_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    INNER_PRODUCT_LINK default = $(1:G=)$(/)$(1:BG=) ;
                    if $(VARIANT) = normal {
                        INNER_PRODUCT_LINK_$(VARIANT) default = $(INNER_PRODUCT_LINK)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                        INNER_PRODUCT_LINK_PATH default = Versions$(/)Current$(/)$(1:BG=) ;
                        INNER_PRODUCT_LINK_PATH_$(VARIANT) default = $(INNER_PRODUCT_LINK_PATH)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    }
                }
                else {
                    # standard bundle
                    if $(BUNDLE_STYLE) = SHALLOW {
                        INNER_PRODUCT default = $(1:G=)$(/)$(1:BG=) ;
                    }
                    else {
                        INNER_PRODUCT default = $(1:G=)$(/)Contents$(/)MacOS$(/)$(1:BG=) ;
                    }
                    INNER_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT)$(VARIANT_SUFFIX_$(VARIANT))$(TOOL_SUFFIX) ;
                    INNER_PRODUCT_LINK_$(VARIANT) default = ;
                }
                # inner product should always be ready before the link to it
                if $(INNER_PRODUCT_LINK_$(VARIANT)) {
                    DEPENDS $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                }
                # inner product directory needed for all bundle types
                INNER_PRODUCT_DIR_$(VARIANT) = $(INNER_PRODUCT_$(VARIANT):D) ;
                if ! $(INNER_PRODUCT_DIR_$(VARIANT)) in $(PRODUCT_FILES) {
                    Mkdir $(INNER_PRODUCT_DIR_$(VARIANT)) ;
                    ProductFile $(INNER_PRODUCT_DIR_$(VARIANT)) ;
                }
                if $(INNER_PRODUCT_$(VARIANT)) && $(INNER_PRODUCT_DIR_$(VARIANT)) {
                    DEPENDS $(INNER_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_DIR_$(VARIANT)) ;
                }
                # optionally make inner product dir aside
                if $(ASIDE_DIR) {
                    ASIDE_INNER_PRODUCT_DIR_$(VARIANT) = $(INNER_PRODUCT_DIR_$(VARIANT):G=aside) ;
                    if ! $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) in $(PRODUCT_FILES) {
                        Mkdir $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) ;
                        ProductFileAside $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) ;
                    }
                }
            }
            # Link inner product
            # By default single module linking is done for all but static libraries.
            # If using Interfacer, then a master object file is generated instead.
            # Static libraries have ranlib run on them after all other steps are complete.
            if $(GENERATE_HEADERS) = YES || $(GENERATE_EXPORT_SETS_AND_GLUE) = YES || $(CFM_BRIDGE) = YES {
                GENERATE_MASTER_OBJECT_FILE default = YES ;
            }
            if $(GENERATE_MASTER_OBJECT_FILE) = YES {
                SINGLE_MODULE = NO ;
            }
	    LINK_FILE_LIST_$(VARIANT) on $(INNER_PRODUCT_$(VARIANT)) = $(FILE_LIST_$(VARIANT)) ;
            if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
                # stand alone executable
                if $(GENERATE_MASTER_OBJECT_FILE) = YES {
                    ProcessSingleObjectLink $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) : StandaloneExecutable ;
                }
                else {
                    StandaloneExecutable $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) ;
                }
            }
            else {
                if $(LIBRARY_STYLE) = STATIC && $(KERNEL_MODULE) != YES {
                    # static library
                    if $(GENERATE_MASTER_OBJECT_FILE) = YES {
                        ProcessSingleObjectLink $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) : StaticLibrary ;
                    }
                    else {
                        StaticLibrary $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) ;
                    }
                }
                else {
                    # dylibs, bundles, frameworks, and kernel extensions
                    if $(GENERATE_MASTER_OBJECT_FILE) = YES {
                        ProcessSingleObjectLink $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) : DynamicLibrary ;
                    }
                    else {
                        DynamicLibrary $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) ;
                    }
                }
            }
            ProductFile $(INNER_PRODUCT_$(VARIANT)) ;
            DEPENDS $(INNER_PRODUCT_$(VARIANT)) : $(TARGET_BUILD_DIR) ;
            # optionally copy inner product aside
            if $(ASIDE_DIR) {
                ASIDE_INNER_PRODUCT_$(VARIANT) = $(INNER_PRODUCT_$(VARIANT):G=aside) ;
                ProductFileAside $(ASIDE_INNER_PRODUCT_$(VARIANT)) ;
                PBXCp $(ASIDE_INNER_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                if $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) {
                    DEPENDS $(ASIDE_INNER_PRODUCT_$(VARIANT)) : $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) ;
                }
            }
            # preen
            if $(DEPLOYMENT_POSTPROCESSING) = YES && $(UNSTRIPPED_PRODUCT) != YES {
                STRIPPED_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT_$(VARIANT):G=strip) ;
                DEPENDS $(STRIPPED_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                if $(PRODUCT_TYPE) != Tool && $(PRODUCT_TYPE) != Application {
                    if ( $(PRODUCT_TYPE) = Bundle
                     || ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = BUNDLE ) )
                     && $(KERNEL_MODULE) != YES {
                        STRIPFLAGS default = -x ;
                    }
                    else {
                        STRIPFLAGS default = -S ;
                    }
                }
                if $(SEPARATE_STRIP) = YES
                 || ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC ) 
                 || ( $(STRIPFLAGS) && $(STRIPFLAGS) != -s && $(STRIPFLAGS) != -S && $(STRIPFLAGS) != -x ) {
                    # static libraries and products with nontrivial STRIPFLAGS get an explicit strip call
                    Strip $(STRIPPED_PRODUCT_$(VARIANT)) ;
                    if $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC {
                        Ranlib $(STRIPPED_PRODUCT_$(VARIANT)) ;
                    }
                    ProductFile $(STRIPPED_PRODUCT_$(VARIANT)) ;
                }
                else {
                    # all other products get -s or -S supplied to the linker depending on basic STRIPFLAGS usage
                    if $(STRIPFLAGS) = -S {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -Wl,-S ;
                    }
                    else {
                        if $(STRIPFLAGS) = -x {
                            FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -Wl,-x ;
                        }
                        else {
                            FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -s ;
                        }
                    }
                }
            }
            # make inner product symlink, if any
            if $(INNER_PRODUCT_LINK_$(VARIANT)) {
                SymLink $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_LINK_PATH_$(VARIANT)) ;
                ProductFile $(INNER_PRODUCT_LINK_$(VARIANT)) ;
                DEPENDS $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                # optionally copy inner product link aside
                if $(ASIDE_DIR) {
                    ASIDE_INNER_PRODUCT_LINK_$(VARIANT) = $(INNER_PRODUCT_LINK_$(VARIANT):G=aside) ;
                    ProductFileAside $(ASIDE_INNER_PRODUCT_LINK_$(VARIANT)) ;
                    SymLink $(ASIDE_INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_LINK_PATH_$(VARIANT)) ;
                    DEPENDS $(ASIDE_INNER_PRODUCT_LINK_$(VARIANT)) : $(ASIDE_INNER_PRODUCT_$(VARIANT)) ;
                    DEPENDS $(ASIDE_INNER_PRODUCT_LINK_$(VARIANT)) : $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) ;
                }
            }
            # edit symbols
            # Symbol editing is done directly with the product with linker flags if possible
            # unless a master object file is generated in which case that is edited prior to linking.
            if $(EXPORTED_SYMBOLS_FILE) && $(GENERATE_MASTER_OBJECT_FILE) != YES {
                if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application
                 || ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) != DYNAMIC ) {
                    # !!!:cmolick:20021025 edit using nmedit after the link
                    EditSymbols $(INNER_PRODUCT_$(VARIANT)) : $(EXPORTED_SYMBOLS_FILE) ;
                }
                else {
                    # !!!:cmolick:20021025 attempt to use linker flag
                    FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -Wl,-exported_symbols_list $(EXPORTED_SYMBOLS_FILE) ;
                    DEPENDS $(INNER_PRODUCT_$(VARIANT)) : $(EXPORTED_SYMBOLS_FILE) ;
                }
            }
            # static libraries must have ranlib run on them after all else
            if $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC {
                RANLIB_INNER_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT_$(VARIANT):G=ranlib) ;
                # ranlib depends on link, strip, modeownergroup
                DEPENDS $(RANLIB_INNER_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                if $(STRIPPED_PRODUCT_$(VARIANT)) {
                    DEPENDS $(RANLIB_INNER_PRODUCT_$(VARIANT)) : $(STRIPPED_PRODUCT_$(VARIANT)) ;
                }
                ProductFile $(RANLIB_INNER_PRODUCT_$(VARIANT)) ;
            }
            if $(GENERATE_MASTER_OBJECT_FILE) != YES {
                # Add prelink flags and libraries to link flags if nonempty
                # Because -keep_private_externs was typically specific to prelinking, it is not carried over.
                for _PRELINK_FLAG in $(PRELINK_FLAGS) {
                    if $(_PRELINK_FLAG) != -keep_private_externs {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += $(_PRELINK_FLAG) ;
                    }
                }
                for _PRELINK_LIB in $(PRELINK_LIBS) {
                    if $(_PRELINK_LIB) != -keep_private_externs {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += $(_PRELINK_LIB) ;
                    }
                }
            }
            # Basic link options determine if this is kext, bundle, or library
            if $(KERNEL_MODULE) = YES {
                MODULE_OBJECT_PATH = $(OBJECT_FILE_DIR_$(VARIANT))$(/)$(MODULE_OBJECT_FILE_$(VARIANT)) ;
                FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -static -nostdlib -r -lkmodc++ "$(MODULE_OBJECT_PATH)" -lkmod -lcc_kext ;
            }
            else {
                # Options for products that are not bundles or static libraries
                if $(PRODUCT_TYPE) != Bundle
                 && ! ( $(PRODUCT_TYPE) = Library && ( $(LIBRARY_STYLE) = BUNDLE || $(LIBRARY_STYLE) = STATIC ) ) {
                    if $(PREBINDING) = YES {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -prebind ;
                    }
                    if $(SINGLE_MODULE) = YES && $(PRODUCT_TYPE) != Tool && $(PRODUCT_TYPE) != Application {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -Wl,-single_module ;
                    }
                }
                # Options relating to the type of library desired as output
                if $(PRODUCT_TYPE) = Bundle
                 || ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = BUNDLE ) {
                    FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -bundle ;
                } else {
                    if $(PRODUCT_TYPE) = Framework
                     || ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = DYNAMIC ) {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -dynamiclib ;
                    }
                    else {
                        if $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC {
                            FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -static ;
                        }
                    }
                }
                # Dynamic library link options set version and installed name
                if ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = DYNAMIC )
                 || $(PRODUCT_TYPE) = Framework {
                    if $(DYLIB_COMPATIBILITY_VERSION) {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -compatibility_version "$(DYLIB_COMPATIBILITY_VERSION)" ;
                    }
                    if $(DYLIB_CURRENT_VERSION) {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -current_version "$(DYLIB_CURRENT_VERSION)" ;
                    }
                    if ! $(DYLIB_INSTALL_NAME_BASE) {
                        if $(INSTALL_PATH) {
                            DYLIB_INSTALL_NAME_BASE = $(INSTALL_PATH) ;
                        }
                    }
                    if $(DYLIB_INSTALL_NAME_BASE) {
                        DYLIB_INSTALLED_NAME_$(VARIANT) default = $(DYLIB_INSTALL_NAME_BASE)$(/)$(INNER_PRODUCT_$(VARIANT):G=) ;
                        INSTALLED_NAME_FLAG on $(INNER_PRODUCT_$(VARIANT)) = -install_name \"`echo \"$(DYLIB_INSTALLED_NAME_$(VARIANT))\" | $(SED) 's!//*!/!g'`\" ;
                    }
                }
            }
            # reduce warnings for multiarchitecture builds
            if $(WARNING_LDFLAGS) && ( $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application ) {
                FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += $(WARNING_LDFLAGS) ;
            }
            # profiling link option
            if $(PROFILING_CODE) = YES {
                FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -pg ;
            }
            # other link options
            if $(OTHER_LDFLAGS_$(VARIANT)) {
                FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += $(OTHER_LDFLAGS_$(VARIANT)) ;
            }
        }
        else {
            # no object files present, indicating pure Java
            if $(PRODUCT_TYPE) = Framework {
                if $(CURRENT_VERSION_LINK) {
                    INNER_PRODUCT_$(VARIANT) default = $(1:G=)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)$(1:B)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    INNER_PRODUCT_LINK_$(VARIANT) default = $(1:G=)$(/)$(1:BG=)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    INNER_PRODUCT_LINK_PATH_$(VARIANT) default = Versions$(/)Current$(/)$(1:BG=)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    # inner product link
                    SymLink $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_LINK_PATH_$(VARIANT)) ;
                    ProductFile $(INNER_PRODUCT_LINK_$(VARIANT)) ;
                    NOUPDATE $(INNER_PRODUCT_LINK_$(VARIANT)) ;
                }
                else  {
                    INNER_PRODUCT_$(VARIANT) default = $(1:G=)$(/)$(1:BG=)_$(VARIANT)$(DYNAMIC_LIBRARY_SUFFIX) ;
                }
                ProductFile $(INNER_PRODUCT_$(VARIANT)) ;
                if $(DYLIB_COMPATIBILITY_VERSION) {
                    DYLIB_VERSION_FLAGS on $(INNER_PRODUCT_$(VARIANT)) += -compatibility_version "$(DYLIB_COMPATIBILITY_VERSION)" ;
                }
                else {
                    DYLIB_VERSION_FLAGS on $(INNER_PRODUCT_$(VARIANT)) += -compatibility_version 1 ;
                }
                if $(DYLIB_CURRENT_VERSION) {
                    DYLIB_VERSION_FLAGS on $(INNER_PRODUCT_$(VARIANT)) += -current_version "$(DYLIB_CURRENT_VERSION)" ;
                }
                else {
                    DYLIB_VERSION_FLAGS on $(INNER_PRODUCT_$(VARIANT)) += -current_version 1 ;
                }
                if ! $(DYLIB_INSTALL_NAME_BASE) {
                    if $(INSTALL_PATH) {
                        DYLIB_INSTALL_NAME_BASE = $(INSTALL_PATH) ;
                    }
                }
                GenerateFrameworkStub $(INNER_PRODUCT_$(VARIANT)) ;
                INNER_PRODUCT_DIR = $(INNER_PRODUCT_$(VARIANT):D) ;
                if ! $(INNER_PRODUCT_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(INNER_PRODUCT_DIR) ;
                    ProductFile $(INNER_PRODUCT_DIR) ;
                    DEPENDS $(INNER_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_DIR) ;
                }
                if $(INNER_PRODUCT_LINK_$(VARIANT)) {
                    SymLink $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_LINK_PATH_$(VARIANT)) ;
                    NOUPDATE $(INNER_PRODUCT_LINK_$(VARIANT)) ; 
                    ProductFile $(INNER_PRODUCT_LINK_$(VARIANT)) ;
                }
            }
        }
        # Java processing compatible with the presense of object files
        if $(COMPILED_JAVA) {
            # provide stub executable if necessary
            if $(JAVA_ONLY) = YES {
                INNER_PRODUCT_$(VARIANT) default = $(1:G=)$(/)Contents$(/)MacOS$(/)$(1:BG=) ;
                # must first make subfolder and depend on that
                INNER_PRODUCT_SUBDIR = $(INNER_PRODUCT_$(VARIANT):D) ;
                if ! $(INNER_PRODUCT_SUBDIR) in $(PRODUCT_FILES) {
                    Mkdir $(INNER_PRODUCT_SUBDIR) ;
                    ProductFile $(INNER_PRODUCT_SUBDIR) ;
                }
                Cp $(INNER_PRODUCT_$(VARIANT)) : $(JAVA_APP_STUB) ;
                ProductFile $(INNER_PRODUCT_$(VARIANT)) ;
            }
        }
        # Add jar/zip files that are in the link phase to the classpath
        if $(OTHER_JAVA_CLASS_PATH) {
            export LINKED_CLASS_ARCHIVES = :"$(OTHER_JAVA_CLASS_PATH)" ;
        }
        else {
            export LINKED_CLASS_ARCHIVES = "" ;
        }
        for JAVA_CLASS_SEARCH_PATH in $(JAVA_CLASS_SEARCH_PATHS) {
            LINKED_CLASS_ARCHIVES = "$(LINKED_CLASS_ARCHIVES):$(JAVA_CLASS_SEARCH_PATH)" ;
        }
        local ARCHIVE ;
        
        for ARCHIVE in $(LINKED_FILES_$(VARIANT)) {
            switch $(ARCHIVE) {
            case *.framework :
                local FW_SUBDIR ;
                for FW_SUBDIR in $(JAVA_FRAMEWORK_RESOURCES_DIRS) {
                    LINKED_CLASS_ARCHIVES = $(LINKED_CLASS_ARCHIVES):$(ARCHIVE)$(/)$(FW_SUBDIR)$(/)Java ;
                    JAVA_FRAMEWORK_JARS += $(ARCHIVE)$(/)$(FW_SUBDIR)$(/)Java ;
                }
            case *.jar :
                LINKED_CLASS_ARCHIVES = $(LINKED_CLASS_ARCHIVES):$(ARCHIVE) ;
                if Merge in $($(ARCHIVE)_ATTRIBUTES) {
                    # merge archive contents by unpacking them into hierarchy
                    local DESTINATION_TARGET = $(CLASS_FILE_DIR:G=Unarchive$(ARCHIVE)) ;
                    NOTFILE $(DESTINATION_TARGET) ;
                    DEPENDS $(DESTINATION_TARGET) : $(JAVA_COMPILE_TARGET) ;
                    if $(MERGED_ARCHIVES) {
                        MERGED_ARCHIVES += $(DESTINATION_TARGET) ;
                    }
                    else {
                        MERGED_ARCHIVES = $(DESTINATION_TARGET) ;
                    }
                    Unarchive $(DESTINATION_TARGET) : $(ARCHIVE) ;
                }
            case *.zip :
                LINKED_CLASS_ARCHIVES = $(LINKED_CLASS_ARCHIVES):$(ARCHIVE) ;
                if Merge in $($(ARCHIVE)_ATTRIBUTES) {
                    # merge archive contents by unpacking them into hierarchy
                    local DESTINATION_TARGET = $(CLASS_FILE_DIR:G=Unarchive$(ARCHIVE)) ;
                    NOTFILE $(DESTINATION_TARGET) ;
                    DEPENDS $(DESTINATION_TARGET) : $(JAVA_COMPILE_TARGET) ;
                    if $(MERGED_ARCHIVES) {
                        MERGED_ARCHIVES += $(DESTINATION_TARGET) ;
                    }
                    else {
                        MERGED_ARCHIVES = $(DESTINATION_TARGET) ;
                    }
                    Unarchive $(DESTINATION_TARGET) : $(ARCHIVE) ;
                }
            }
        }
        # generate an archive if there are compiled or merged classes
        if $(COMPILED_JAVA) || $(MERGED_ARCHIVES) || $(COPIED_JAVA_RESOURCES) {
	    if $(JAVA_ARCHIVE_CLASSES) != NO {
	        # java archive suffix applies to applications and frameworks
	        if $(JAVA_ARCHIVE_TYPE) = JAR {
		    CLASS_ARCHIVE_SUFFIX default = .jar ;
	        }
	        else {
		    if $(JAVA_ARCHIVE_TYPE) = ZIP {
		        CLASS_ARCHIVE_SUFFIX default = .zip ;
		    }
	        }
	        if ( $(PRODUCT_TYPE) = Bundle
                  || $(PRODUCT_TYPE) = Application
                  || $(PRODUCT_TYPE) = Framework ) {
                    # Assume bundled products with object files are Cocoa
		    CLASS_ARCHIVE default = $(RESOURCE_DIR)$(/)Java$(/)$(1:B)$(CLASS_ARCHIVE_SUFFIX) ;
                    ProductFile $(CLASS_ARCHIVE) ;
	        }
	        else {
                    CLASS_ARCHIVE default = $(1:B:G=)$(CLASS_ARCHIVE_SUFFIX) ;
                    # It is critical for the class archive to be declared
                    # a product file before any symlinks to it are made
                    # which would conditionally involved declaring the
                    # symbolic link content to not be a file.
                    ProductFile $(CLASS_ARCHIVE) ;
                    # ref. w/suffix for tool or library in deployment location
                    if $(DEPLOYMENT_LOCATION) = YES {
                        _ARCHIVE_REFERENCE default = $(BUILT_PRODUCTS_DIR:G=ArchiveRef)$(/)$(CLASS_ARCHIVE) ;
                        SymLink $(_ARCHIVE_REFERENCE) : $(CLASS_ARCHIVE) ;
                        DEPENDS $(_ARCHIVE_REFERENCE) : $(BUILT_PRODUCTS_DIR) ;
                        DEPENDS $(1) : $(_ARCHIVE_REFERENCE) ;
                    }
                    # Make a link to the product without extension
                    # to allow for references missing extension.
                    _SUFFIX_FREE_ARCHIVE_REFERENCE = $(BUILT_PRODUCTS_DIR:G=SuffixFreeArchiveRef)$(/)$(CLASS_ARCHIVE:S=) ;
                    SymLink $(_SUFFIX_FREE_ARCHIVE_REFERENCE) : $(CLASS_ARCHIVE) ;
                    DEPENDS $(_SUFFIX_FREE_ARCHIVE_REFERENCE) : $(BUILT_PRODUCTS_DIR) ;
                    DEPENDS $(1) : $(_SUFFIX_FREE_ARCHIVE_REFERENCE) ;
    	        }
                # class archive depends on target build dir
                DEPENDS $(CLASS_ARCHIVE) : $(TARGET_BUILD_DIR) ;
                # class archive depends on class archive dir (if defined)
                CLASS_ARCHIVE_DIR = $(CLASS_ARCHIVE:D:G=) ;
                if $(CLASS_ARCHIVE_DIR) && ! $(CLASS_ARCHIVE_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(CLASS_ARCHIVE_DIR) ;
                    ProductFile $(CLASS_ARCHIVE_DIR) ;
                }
	        # class files unknown, so archive depends on java compile log
	        ClassArchive $(CLASS_ARCHIVE) : $(CLASS_FILE_DIR) ;
	        if $(MERGED_ARCHIVES) {
                    DEPENDS $(CLASS_ARCHIVE) : $(MERGED_ARCHIVES) ;
                }
                if $(COMPILED_JAVA) {
                    DEPENDS $(CLASS_ARCHIVE) : $(JAVA_COMPILE_TARGET) ;
                }
                if $(COPIED_JAVA_RESOURCES) {
                    DEPENDS $(CLASS_ARCHIVE) : $(COPIED_JAVA_RESOURCES) ;
                }
	    }
            if $(JAVA_ARCHIVE_CLASSES) != YES {
                # !!!:cmolick:20020123 product class file dir not always made?!
                Mkdir $(PRODUCT_CLASS_FILE_DIR) ;
                ProductFile $(PRODUCT_CLASS_FILE_DIR) ;
                Ditto $(PRODUCT_CLASS_FILE_DIR) : $(CLASS_FILE_DIR) ;
	        if $(MERGED_ARCHIVES) {
                    DEPENDS $(PRODUCT_CLASS_FILE_DIR) : $(MERGED_ARCHIVES) ;
                }
                else {
                    DEPENDS $(PRODUCT_CLASS_FILE_DIR) : $(JAVA_COMPILE_TARGET) ;
                }
            }
        }
	# Export the path to the inner product, if any.
	export INNER_PRODUCT_SUBPATH = $(INNER_PRODUCT:G=) ;
	# Build phasing bookkeeping
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
    }
}

rule ProcessFrameworkOrLibrary
{
    for VARIANT in $(BUILD_VARIANTS) {
    LINKED_FILES_$(VARIANT) += $(2) ;
    }
}

# ProcessRezFiles <product> <rez and resmerger input files>
#
# Processes Rez and ResMerger input files, or if there are none
# and type and creator are set uses SetFile to set type and creator.
rule ProcessRezFiles
{
    if ( build in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : RezResourceManagerFiles ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        if $(2) {
            for FILE in $(2) {
                if $(_BUILD_PHASING) = YES {
                    ProcessRezFile $(BUILD_PHASE) : $(FILE) ;
                }
                else {
                    ProcessRezFile $(1) : $(FILE) ;
                }
            }
        }
        else {
            if ( $(MACOS_TYPE) || $(MACOS_CREATOR) ) && $(REZ_EXECUTABLE) = YES {
                local RESOURCE_FORK = $(INNER_PRODUCT:G=ResourceFork) ;
                if ! $(INNER_PRODUCT) in $(PRESERVE_RESOURCES) {
                     PRESERVE_RESOURCES += $(INNER_PRODUCT) ;
                }
                ProductFile $(RESOURCE_FORK) ;
                if $(ALWAYS_REZ) = YES {
                    ALWAYS $(RESOURCE_FORK) ;
                }
                SetFile $(RESOURCE_FORK) ;
            }
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

# ProcessRezFile <product or phase> <rez or resmerger input file>
#
# Sets up the compile of one Rez or ResMerger input file.
# RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR	folder for resource collectors
# RESOURCE_MANAGER_RESOURCE_COLLECTOR		resource collector
# RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)	localized collector
# RESOURCE_MANAGER_RESOURCE			final resource destination
# RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR	localized final folder
# RESOURCE_MANAGER_RESOURCE_$(REGION)		localized final destination
rule ProcessRezFile
{
    if source in $(BUILD_COMPONENTS) {
        local REZ_SOURCE_COPY ;
        local REZ_SOURCE_DIR ;
        # make directory first if necessary
        if $(2:D) {
            REZ_SOURCE_DIR = $(SOURCE_DIR)/$(2:D:G=) ;
            Mkdir $(REZ_SOURCE_DIR) ;
            REZ_SOURCE_COPY = $(REZ_SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(REZ_SOURCE_COPY) : $(REZ_SOURCE_DIR) ;
        }
        else {
            REZ_SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(REZ_SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        # copy rez files to source location
        Cp $(REZ_SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(REZ_SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        local REGION = $($(2)_REGION) ;
        # scan for header files
        if $(ENABLE_HEADER_DEPENDENCIES) != NO && $(DO_HEADER_SCANNING_IN_JAM) = YES {
            HDRRULE on $(2) = ProcessC.HdrRule ;
            HDRSCAN on $(2) = $(HDRPATTERN) ;
        }
        # all resources require a folder to hold any collector
        if ! $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) {
            RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR = $(TEMP_DIR)$(/)ResourceManagerResources ;
            Mkdir $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
            ProductFile $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
        }
        if $(REZ_EXECUTABLE) = YES {
            # Optionally accumulate ResourceManager resources
            # on a resource fork of the executable
            PRESERVE_RESOURCES += $(INNER_PRODUCT) ;
            if ! $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) {
                RESOURCE_MANAGER_RESOURCE_COLLECTOR = $(INNER_PRODUCT:BG=ResourceManagerResourceCollector) ;
                DEPENDS $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
            }
            if $(2:S) = ".r" {
                RezCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(2) ;
            } else {
                ResMergerCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(2) ;
            }
            # The collector must be declared a product file
            # only after the first Collector rule invocation
            # to correctly initialize the collector.
            ProductFile $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) ;
            # location must be set after ProductFile invocation
            LOCATE on $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) = $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
            if ! $(RESOURCE_MANAGER_RESOURCE) {
                RESOURCE_MANAGER_RESOURCE = $(INNER_PRODUCT:G=ResourceManagerResource) ;
                ProductFile $(RESOURCE_MANAGER_RESOURCE) ;
                ResMergerProduct $(RESOURCE_MANAGER_RESOURCE) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) ;
            }
        }
        else {
            # By default ResourceManager resources are stored in data forks
            # as Resources/<product>.rsrc files if non localized, or 
            # Resources/<region>.lproj/Localized.rsrc files if localized.
            if $(REGION) {
                # localized resource collector
                if ! $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) {
                    RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION) = $(REGION).rsrc ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
                }
                if $(2:S) = ".r" {
                    RezCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) : $(2) ;
                } else {
                    ResMergerCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) : $(2) ;
                }
                # collector declared product after first Collector rule invocation
                ProductFile $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) ;
                # set location only after ProductFile invocation
                LOCATE on $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) = $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
                # localized resource folder
                RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR = $(RESOURCE_DIR)$(/)$(REGION).lproj ;
                Mkdir $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                ProductFile $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                # localized resource
                if ! $(RESOURCE_MANAGER_RESOURCE_$(REGION)) {
                    RESOURCE_MANAGER_RESOURCE_$(REGION) = $(RESOURCE_DIR)$(/)$(REGION).lproj$(/)Localized.rsrc ;
                    ProductFile $(RESOURCE_MANAGER_RESOURCE_$(REGION)) ;
                    # folder for localized resource
                    RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR = $(RESOURCE_DIR)$(/)$(REGION).lproj ;
                    Mkdir $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                    ProductFile $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) : $(RESOURCE_DIR) ;
                    # get product from collector
                    ResMergerProduct $(RESOURCE_MANAGER_RESOURCE_$(REGION)) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE_$(REGION)) : $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                }
            }
            else {
                # nonlocalized resource collector
                if ! $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) {
                    RESOURCE_MANAGER_RESOURCE_COLLECTOR = $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR)$(/)$(1:S=.rsrc:G=) ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
                }
                if $(2:S) = ".r" {
                    RezCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(2) ;
                } else {
                    ResMergerCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(2) ;
                }
                # collector declared product after Collector rule invocation
                ProductFile $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) ;
                # nonlocalized resource
                if ! $(RESOURCE_MANAGER_RESOURCE) {
                    RESOURCE_MANAGER_RESOURCE = $(RESOURCE_DIR)$(/)$(1:S=.rsrc:G=) ;
                    ProductFile $(RESOURCE_MANAGER_RESOURCE) ;
                    # get product from collector
                    ResMergerProduct $(RESOURCE_MANAGER_RESOURCE) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE) : $(RESOURCE_DIR) ;
                    if $(ALWAYS_REZ) = YES {
                        ALWAYS $(RESOURCE_MANAGER_RESOURCE) ;
                    }
                }
            }

            if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
                Mkdir $(RESOURCE_DIR) ;
                ProductFile $(RESOURCE_DIR) ;
            }
        }
        # create accompanying link in the case of versioned frameworks
        if $(RESOURCE_LINK) 
         && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
            SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
            ProductFile $(RESOURCE_LINK) ;
        }
    }
}

rule ProcessScriptBuildPhaseFiles
{
    if source in $(BUILD_COMPONENTS) || headers in $(BUILD_COMPONENTS) || build in $(BUILD_COMPONENTS) {
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : Script ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        if build in $(BUILD_COMPONENTS)
         || ( headers in $(BUILD_COMPONENTS) && $(INSTALLHDRS_SCRIPT_PHASE) = YES ) {
            SEARCH on $(2) = $(SOURCE_ROOT) $(TEMP_ROOT) ;
            PHASE_SCRIPT_EXECUTION = $(2:G=Execution) ;
            NOTFILE $(PHASE_SCRIPT_EXECUTION) ;
            ALWAYS $(PHASE_SCRIPT_EXECUTION) ;
            DEPENDS $(1) : $(PHASE_SCRIPT_EXECUTION) ;
            PhaseScriptExecution $(PHASE_SCRIPT_EXECUTION) : $(2) ;
            if ! $(PHASE_SCRIPT_EXECUTION) in $(PRODUCT_FILES) {
                if $(_BUILD_PHASING) = YES {
                    BUILD_PHASE_PRODUCTS += $(PHASE_SCRIPT_EXECUTION) ;
                }
            }
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
                if $(PREVIOUS_BUILD_PHASE) {
                    # !!!:cmolick:20021119 depend on previous phase or products to get timing right?
                    DEPENDS $(BUILD_PHASE_PRODUCTS) : $(PREVIOUS_BUILD_PHASE) ;
                }
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

rule PhaseScriptExecution
{
    JAMSHOULDSETENV on $(1) = YES ;
    DEPENDS $(1) : $(2) ;
}
actions exportvars PhaseScriptExecution
{
    echo "=== Script ==="
    cat $(2:Q)
    echo "--- Output ---"
    $(2:Q)
    _result=$?
    echo "=== Exit code: ${_result} ==="
    exit ${_result}
}

rule ProcessCopyFiles
{
    if $(_BUILD_PHASING) = YES {
        PhaseTarget BUILD_PHASE : $(1) : CopyFiles ;
        BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
        BUILD_PHASE_PRODUCTS = ;
    }
    if build in $(BUILD_COMPONENTS)
     || ( headers in $(BUILD_COMPONENTS) && $(INSTALLHDRS_COPY_PHASE) = YES ) {
        SEARCH on $(2) = $(SOURCE_ROOT) ;
        for FILE in $(2) {
            ProcessCopyFile $(1) : $(FILE) : $(COPYFILES_DESTINATION_PATH) ;
        }
    }
    if $(_BUILD_PHASING) = YES {
        if $(BUILD_PHASE_PRODUCTS) {
            DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
        }
        PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
    }
}

rule ProcessCopyFile
{
    if source in $(BUILD_COMPONENTS) {
        local SOURCE_COPY ;
        local SOURCE_SUBDIR ;
        # copy files to source location
        # make directory first if necessary
        if $(2:D) {
            SOURCE_SUBDIR = $(2:D:G=SourceCopy) ;
            Mkdir $(SOURCE_SUBDIR) ;
            SOURCE_COPY = $(SOURCE_SUBDIR)/$(2:D=:G=) ;
            DEPENDS $(SOURCE_COPY) : $(SOURCE_SUBDIR) ;
        }
        else {
            SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        Cp $(SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) || headers in $(BUILD_COMPONENTS) {
        local DESTINATION_DIR = $(3) ;
        if ! $(DESTINATION_DIR) in $(PRODUCT_FILES) {
            Mkdir $(DESTINATION_DIR) ;
            ProductFile $(DESTINATION_DIR) ;
        }
        local DESTINATION_BASE = $(2:BS) ;
        local DESTINATION default = $(DESTINATION_DIR)$(/)$(DESTINATION_BASE) ;
        DEPENDS $(DESTINATION) : $(DESTINATION_DIR) ;
        DEPENDS $(DESTINATION) : $(2) ;
        ProductFile $(DESTINATION) ;
        LOCATE on $(DESTINATION) = $(DESTINATION_DIR) ;
        PBXCp $(DESTINATION) : $(2) ;
    }
}

rule ProcessJavaResourceFiles
{
    if build in $(BUILD_COMPONENTS) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : JavaArchiveFiles ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        LOCATE on $(2) = $(SOURCE_ROOT) ;
        for FILE in $(2) {
            ProcessJavaResourceFile $(1) : $(FILE) : $(CLASS_FILE_DIR) ;
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

rule ProcessJavaResourceFile
{
    local ARCHIVE_PATH ;
    local ARCHIVE_DESTINATION ;
    local ARCHIVE_DESTINATION_FILE ;

    # copy any other reference - formulate destination first
    if $($(2)_JAVA_ARCHIVE_SUBDIR) {
        ARCHIVE_DESTINATION_DIR = $(3)$(/)$($(2)_JAVA_ARCHIVE_SUBDIR) ;
    }
    else {
        # if there's no setting, just copy the file to the root of the archive.
        ARCHIVE_DESTINATION_DIR = $(3) ;
    }
    ARCHIVE_DESTINATION_FILE = $(ARCHIVE_DESTINATION_DIR)/$(2:BS) ;
    Mkdir $(ARCHIVE_DESTINATION_DIR) ;
    ProductFile $(ARCHIVE_DESTINATION_DIR) ;
    PBXCp $(ARCHIVE_DESTINATION_FILE:G=populated) : $(2) ;
    ProductFile $(ARCHIVE_DESTINATION_FILE:G=populated) ;
    DEPENDS $(ARCHIVE_DESTINATION_FILE:G=populated) : $(ARCHIVE_DESTINATION_DIR) ;

    # copied content depends on source
    DEPENDS $(ARCHIVE_DESTINATION_FILE) : $(2) ;
    # set contents present for archival flag by making COPIED_JAVA_RESOURCES nonempty
    COPIED_JAVA_RESOURCES += $(2) ;
}

# Following rules are used by ProcessSource
# to attend to specific types of source file.

rule ProcessUsingJavaCompiler
{
    # Compile .java to .class files using javac or jikes
    # Because what class files will be generated by the java compiler
    # can't be known in advance, an abstract target is used for this step.
    if $(JAVA_COMPILE_TARGET) = "" {
        JAVA_COMPILE_TARGET = $(1:G=CompileJava) ;
        NOTFILE $(JAVA_COMPILE_TARGET) ;
        DEPENDS $(1) : $(JAVA_COMPILE_TARGET) ;
        DEPENDS $(JAVA_COMPILE_TARGET) : $(CLASS_FILE_DIR) ;
        # bridge derived java to be generated and compiled first
        if $(JAVA_BRIDGE_COMPILE_TARGET) {
            DEPENDS $(JAVA_COMPILE_TARGET) : $(JAVA_BRIDGE_COMPILE_TARGET) ;
        }
    }
    
    export JAVA_SOURCE_PATH default = $(SOURCE_ROOT)$(/)$(JAVA_SOURCE_SUBDIR) ;

    # start with the compiler-specific flags.
    if $(JAVA_COMPILER:B) = jikes {
        export JAVAC_FLAGS = $(JIKES_DEFAULT_FLAGS) ;
    }
    else if $(JAVA_COMPILER:B) = javac {
        export JAVAC_FLAGS = $(JAVAC_DEFAULT_FLAGS) ;
    }
    else {
        export JAVAC_FLAGS = ;
    }
    
    if $(JAVA_COMPILER_DISABLE_WARNINGS) = YES {
        JAVAC_FLAGS += "-nowarn" ;
    }
    if $(JAVA_COMPILER_DEPRECATED_WARNINGS) = YES {
        JAVAC_FLAGS += "-deprecation" ;
    }
    JAVAC_FLAGS += $(JAVA_COMPILER_FLAGS) ;

    if $(JAVA_COMPILER_TARGET_VM_VERSION) {
        if $(JAVA_COMPILER:B) = jikes {
            ECHO warning: Target VM version not supported by jikes ;
        }
        else {
            JAVAC_FLAGS += "-target "$(JAVA_COMPILER_TARGET_VM_VERSION) ;
        }
    }
    
    if $(JAVA_COMPILER_SOURCE_VERSION) {
        JAVAC_FLAGS += "-source "$(JAVA_COMPILER_SOURCE_VERSION) ;
    }
    
    if $(JAVA_COMPILER_DEBUGGING_SYMBOLS) = YES {
        JAVAC_FLAGS += "-g" ;
    }
    
    if $(JAVAC_SOURCE_FILE_ENCODING) {
        JAVAC_FLAGS += -encoding "$(JAVAC_SOURCE_FILE_ENCODING)" ;
    }

    if $(JAVA_FORCE_FILE_LIST) = "NO" && ( $(JAVA_USE_DEPENDENCIES) = "NO" || ( ! $($(2)_JAVA_IMPORTS) && empty$($(2)_JAVA_IMPORTS) != empty ) ) {
        # With no dependence, or dependence info usage off
        # build with combinded compiler invocations but no file list
        DEPENDS $(JAVA_COMPILE_TARGET) : $(2) ;
        ALWAYS $(JAVA_COMPILE_TARGET) ;
        JAVAC_FLAGS on $(JAVA_COMPILE_TARGET) = $(JAVAC_FLAGS) ;
        JAVA_COMPILER on $(JAVA_COMPILE_TARGET) = $(JAVA_COMPILER) ;
        if $(JAVA_COMPILER:B) = jikes {
	    JavaCompile.jikes $(JAVA_COMPILE_TARGET) : $(2) ;
        }
        else {
	    JavaCompile.default $(JAVA_COMPILE_TARGET) : $(2) ;
        }
        COMPILED_JAVA += $(2) ;
        if ! $(JAVA_COMPILE_TARGET) in $(PRODUCT_FILES) {
            ProductFile $(JAVA_COMPILE_TARGET) ;
        }
    }
    else {
        # Using dependence info, set up file list for java compiles
        JAVA_FILE_LIST default = $(TEMP_DIR)$(/)JavaFileList ;
        # define and act on target to clear list
        if ! $(CLEAR_JAVA_FILE_LIST) {
            CLEAR_JAVA_FILE_LIST = $(JAVA_FILE_LIST:G=ClearFileList) ;
            ClearJavaFileList $(CLEAR_JAVA_FILE_LIST) ;
            DEPENDS $(JAVA_COMPILE_TARGET) : $(CLEAR_JAVA_FILE_LIST) ;
        }
        # set up compile target to use file list
        if ! $(JAVA_COMPILE_TARGET) in $(PRODUCT_FILES) {
            JAVAC_FLAGS on $(JAVA_COMPILE_TARGET) = $(JAVAC_FLAGS) ;
            JAVA_COMPILER on $(JAVA_COMPILE_TARGET) = $(JAVA_COMPILER) ;
            JAVA_FILE_LIST_REFERENCE = @$(JAVA_FILE_LIST) ;
            NOTFILE $(JAVA_FILE_LIST_REFERENCE) ;
            if $(JAVA_COMPILER:B) = jikes {
	        JavaCompile.jikes $(JAVA_COMPILE_TARGET) : $(JAVA_FILE_LIST_REFERENCE) ;
            }
            else {
	        JavaCompile.default $(JAVA_COMPILE_TARGET) : $(JAVA_FILE_LIST_REFERENCE) ;
            }
            ProductFile $(JAVA_COMPILE_TARGET) ;
        }
        # set up class file dependence used to add java files to compile list
        local CLASS_FILE ;
        # use the main class, if it's there
        if $($(2)_MAIN_CLASS) {
            CLASS_FILE = $(CLASS_FILE_DIR)$(/)$($(2)_MAIN_CLASS) ;
        }
        else {
            local JAVA_SOURCE ;
            RemovePrefixPath JAVA_SOURCE : $(JAVA_SOURCE_SUBDIR) : $(2) ;
            CLASS_FILE = $(CLASS_FILE_DIR)$(/)$(JAVA_SOURCE:S=.class) ;
        }
        DEPENDS $(CLASS_FILE) : $(2) ;
        if $($(2)_JAVA_IMPORTS) {
            DEPENDS $(CLASS_FILE) : $($(2)_JAVA_IMPORTS) ;
            DEPENDS $(CLEAR_JAVA_FILE_LIST) : $($(2)_JAVA_IMPORTS) ;
        }
        DEPENDS $(JAVA_COMPILE_TARGET) : $(CLASS_FILE) ;
        JAVA_FILE_LIST on $(CLASS_FILE) = $(JAVA_FILE_LIST) ;
        AppendToJavaFileList $(CLASS_FILE) : $(2) ;
        DEPENDS $(CLEAR_JAVA_FILE_LIST) : $(2) ;
        COMPILED_JAVA += $(2) ;
    }
}

actions quietly together piecemeal ClearJavaFileList
{
    $(RM) -rf $(JAVA_FILE_LIST:Q) && $(TOUCH) $(JAVA_FILE_LIST:Q)
}

# Appends reference to list only if not already present
actions quietly together piecemeal AppendToJavaFileList
{
    _grep_result=`/usr/bin/grep -e \""$(2)"\" $(JAVA_FILE_LIST:Q)`
    if [ "x$_grep_result" = "x" ]
      then $(ECHO) \""$(2)"\" >> $(JAVA_FILE_LIST:Q)
    fi
}

actions together piecemeal JavaCompile.default {
    frameworkjars=""
    for i in `echo $(JAVA_FRAMEWORK_JARS)/*.jar $(JAVA_FRAMEWORK_JARS)/*.zip ` ; do if [ -f "$i" ] ; then frameworkjars="$frameworkjars":"$i" ; fi ; done
    classpath="$(CLASS_FILE_DIR)$(LINKED_CLASS_ARCHIVES)$frameworkjars:"`$(JAVACONFIG) DefaultClasspath`
    $(JAVA_COMPILER) $(JAVAC_FLAGS) $($(2)_COMPILER_FLAGS) -sourcepath $(JAVA_SOURCE_PATH:Q) -classpath "$classpath" -d "$(CLASS_FILE_DIR)" '$(2)'
}
actions together piecemeal JavaCompile.jikes {
    frameworkjars=""
    for i in `echo $(JAVA_FRAMEWORK_JARS)/*.jar $(JAVA_FRAMEWORK_JARS)/*.zip ` ; do if [ -f "$i" ] ; then frameworkjars="$frameworkjars":"$i" ; fi ; done
    classpath="$(CLASS_FILE_DIR)$(LINKED_CLASS_ARCHIVES)$frameworkjars:"`$(JAVACONFIG) DefaultClasspath`
    $(JAVA_COMPILER) $(JAVAC_FLAGS) $($(2)_COMPILER_FLAGS) -sourcepath $(JAVA_SOURCE_PATH:Q) -classpath "$classpath" -d $(CLASS_FILE_DIR:Q) '$(2)'
}

rule ProcessApplescripts
{
    if build in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : CompileAppleScripts ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        if $(CONTEXTNAME) = ""
        {
            for FILE in $(2) {
                if $(_BUILD_PHASING) = YES {
                    ProcessAppleScript $(BUILD_PHASE) : $(FILE) : $(FILE) ;
                }
                else {
                    ProcessAppleScript $(1) : $(FILE) : $(FILE) ;
                }
            }
        }
        else
        {
            ProcessAppleScript $(1) : $(2) : $(CONTEXTNAME) ;
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

rule ProcessAppleScript
{
    if source in $(BUILD_COMPONENTS) {
        # make directory first if necessary
        if $(2:D) {
            SCRIPT_SOURCE_DIR = $(2:D:G=) ;
            Mkdir $(SCRIPT_SOURCE_DIR) ;
            SCRIPT_SOURCE_COPY = $(SCRIPT_SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(SCRIPT_SOURCE_COPY) : $(SCRIPT_SOURCE_DIR) ;
        }
        else {
            SCRIPT_SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(SCRIPT_SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        # copy script to source location
        Cp $(SCRIPT_SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(SCRIPT_SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        if $(2) = $(3) {
            # third argument is a file (ignore subfolder for result)
            APPLESCRIPT_FILE = $(APPLESCRIPTS_DIR)$(/)$(3:BS=.scpt) ;
        }
        else {
            # third argument is a context name
            APPLESCRIPT_FILE = $(APPLESCRIPTS_DIR)$(/)$(3:S=.scpt) ;
        }
        DEPENDS $(APPLESCRIPT_FILE) : $(APPLESCRIPTS_DIR) ;
        if ! $(APPLESCRIPTS_DIR) in $(PRODUCT_FILES) {
            Mkdir $(APPLESCRIPTS_DIR) ;
            ProductFile $(APPLESCRIPTS_DIR) ;
        }
        DEPENDS $(APPLESCRIPT_FILE) : $(2) ;
        OTHER_OSAFLAGS on $(APPLESCRIPT_FILE) = $(OTHER_OSAFLAGS) $($(APPLESCRIPT_FILE)_COMPILER_FLAGS) ;
        OSACompile $(APPLESCRIPT_FILE) : $(2) ;
        ProductFile $(APPLESCRIPT_FILE) ;
    }
}

actions OSACompile
{
    $(OSAC) -d -i $(SYSTEM_LIBRARY_DIR)/Frameworks/AppleScriptKit.framework -U $(2:BSQ) -o $(1:Q) "$(OTHER_OSAFLAGS)" $(2:Q)
}

rule ProcessC
{
    for VARIANT in $(BUILD_VARIANTS) {
    for ARCH in $(ARCHS) {
        local OBJECT_FILE ;
        local OBJECT_SUBDIR = $(OBJECT_FILE_DIR_$(VARIANT))$(/)$(ARCH) ;
        # $(2)_UNIQUENAME is defined only if the basename of the file isn't unique within the target.
        if $($(2)_UNIQUENAME) {
            OBJECT_FILE = $($(2)_UNIQUENAME:G=$(VARIANT)-$(ARCH)).o ;
        }
        else {
            OBJECT_FILE = $(2:D=:S=:G=$(VARIANT)-$(ARCH)).o ;
        }
        DEPENDS $(OBJECT_FILE) : $(OBJECT_SUBDIR) ;
        if ! $(OBJECT_SUBDIR) in $(PRODUCT_FILES) {
            Mkdir $(OBJECT_SUBDIR) ;
            PRODUCT_FILES += $(OBJECT_SUBDIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_SUBDIR) ;
            }
        }
        ARCH on $(OBJECT_FILE) = $(ARCH) ;
        PER_ARCH_CFLAGS = $(PER_ARCH_CFLAGS_$(ARCH)) ;
        if $(JAVA_BRIDGET_TARGET) {
            DEPENDS $(OBJECT_FILE) : $(JAVA_BRIDGET_TARGET) ;
        }
        OTHER_CFLAGS on $(OBJECT_FILE) = $(OTHER_CFLAGS_$(VARIANT)) ;
        CompileC $(OBJECT_FILE) : $(2) ;
        if $(2:BS) != $(VECTOR_STUB:BS) {
            # add object file to object files and phase products
            # unless it is the compiled generated vector stub
            OBJECT_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            OBJECT_FILES_$(VARIANT)_$(ARCH) += $(OBJECT_FILE) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_FILE) ;
            }
        }
        LOCATE on $(OBJECT_FILE) = $(OBJECT_SUBDIR) ;
        if $(2) = $(MODULE_INFO_FILE) {
            MODULE_OBJECT_FILE_$(VARIANT) = $(OBJECT_FILE) ;
            LOCATE on $(MODULE_OBJECT_FILE_$(VARIANT)) = $(OBJECT_SUBDIR) ;
            DEPENDS $(1) : $(MODULE_OBJECT_FILE_$(VARIANT)) ;
        }
        else {
            # object file is added to linked files
            # unless it is the compiled generated vector stub
            if $(2:BS) != $(VECTOR_STUB:BS) {
                LINKED_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            }
        }
    }
    }
}

rule ProcessCplusplus
{
    for VARIANT in $(BUILD_VARIANTS) {
    for ARCH in $(ARCHS) {
        local OBJECT_FILE ;
        local OBJECT_SUBDIR = $(OBJECT_FILE_DIR_$(VARIANT))$(/)$(ARCH) ;
        # $(2)_UNIQUENAME is defined only if the basename of the file isn't unique within the target.
        if $($(2)_UNIQUENAME) {
            OBJECT_FILE = $($(2)_UNIQUENAME:G=$(VARIANT)-$(ARCH)).o ;
        }
        else {
            OBJECT_FILE = $(2:D=:S=:G=$(VARIANT)-$(ARCH)).o ;
        }
        DEPENDS $(OBJECT_FILE) : $(OBJECT_SUBDIR) ;
        if ! $(OBJECT_SUBDIR) in $(PRODUCT_FILES) {
            Mkdir $(OBJECT_SUBDIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_SUBDIR) ;
            }
        }
        ARCH on $(OBJECT_FILE) = $(ARCH) ;
        PER_ARCH_CPLUSPLUSFLAGS_$(ARCH) default = $(PER_ARCH_CFLAGS_$(ARCH)) ;
        PER_ARCH_CPLUSPLUSFLAGS = $(PER_ARCH_CPLUSPLUSFLAGS_$(ARCH)) ;
        OTHER_CPLUSPLUSFLAGS on $(OBJECT_FILE) = $(OTHER_CPLUSPLUSFLAGS_$(VARIANT)) ;
        CompileCplusplus $(OBJECT_FILE) : $(2) ;
        OBJECT_FILES_$(VARIANT) += $(OBJECT_FILE) ;
        OBJECT_FILES_$(VARIANT)_$(ARCH) += $(OBJECT_FILE) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(OBJECT_FILE) ;
        }
        if $(2) = $(MODULE_INFO_FILE_$(VARIANT)) {
            MODULE_OBJECT_FILE_$(VARIANT) = $(OBJECT_FILE) ;
            LOCATE on $(MODULE_OBJECT_FILE_$(VARIANT)) = $(OBJECT_SUBDIR) ;
            DEPENDS $(1) : $(MODULE_OBJECT_FILE_$(VARIANT)) ;
        }
        else {
            LOCATE on $(OBJECT_FILE) = $(OBJECT_SUBDIR) ;
            LINKED_FILES_$(VARIANT) += $(OBJECT_FILE) ;
        }
    }
    }
}

HDRPATTERN = "^[	 ]*#[	 ]*include[	 ]*[<\"](.*)[\">].*$" ;
HDRPATTERN += "^[	 ]*#[	 ]*import[	 ]*[<\"](.*)[\">].*$" ;

rule ProcessC.HdrRule
{
    # header reference in subdirectory source may be to header in that subdirectory
    local LOCAL_HEADERS = $(2:D=$(1:D)) ;
    # or header reference may be to elsewhere
    local FOREIGN_HEADERS = $(2) ;
    # compiled sources may include headers in subdirectories
    INCLUDES $(1) : $(LOCAL_HEADERS) $(FOREIGN_HEADERS) ;
}

rule CompileC
{
    # object file depends on the source file
    DEPENDS $(1) : $(2) ;
    # Initialize the flags, and set search paths to nothing
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_HEADERS) $(KERNEL_HEADERS)/bsd $(KERNEL_FRAMEWORK)/PrivateHeaders ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) ;
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    if $(CPP_HEADER_SYMLINKS_DIR) {
        FLAGS on $(1) += "-I$(CPP_HEADER_SYMLINKS_DIR)" ;
    }
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;

    # If the source file is in a subdirectory, then search that
    # subdirectory for headers
    if $(2:D) {
        HEADER_SEARCH_PATHS on $(1) += $(2:D) ;
    }
    # We must compile with the extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    # Pass the trusted-precomp file name to the compiler to keep track
    # of which precompiled headers it has already sanity checked.
    if $(GCC_VERSION) != 3.3 && $(GCC_VERSION) != 3.5 && $(OS) in MACOS DARWIN  &&  $(EFFECTIVE_PFE_FILE_$(ARCH)) = "" {
        FLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
    }
    if $(CPP_HEADERMAP_FILE) {
        FLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(1:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    if $(INDEX_GENERATION_PIPE_NAME) != "" {
        FLAGS on $(1) += "-fgen-index=$(INDEX_GENERATION_PIPE_NAME)" ;
    }
    if $(EFFECTIVE_PFE_FILE_$(ARCH)) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            if $(PREFIX_HEADER_CFLAGS_BASE) = -include {
                # GCC v3.3 / v3.5 PCH
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH):S=)" ;            
            }
            else {
                # GCC v3.1 PFE
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH))" ;
            }
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
            }
        }
    }
    if $(EFFECTIVE_PREFIX_HEADER) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            # GCC v2.95.2 cpp-precomp
            PREFIX_HEADER_CFLAGS on $(1) += -include "$(EFFECTIVE_PREFIX_HEADER)" ;
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PREFIX_HEADER) ;
            }
        }
    }
}

actions CompileC
{
    $(CC) -c -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_CFLAGS)" $($(2)_COMPILER_FLAGS) $(2:Q) -o $(1:Q)
}

rule CompileCplusplus
{
    # object file depends on the source file
    DEPENDS $(1) : $(2) ;
    # Initialize the flags, and set search paths to nothing
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_HEADERS) $(KERNEL_HEADERS)/bsd $(KERNEL_FRAMEWORK)/PrivateHeaders ;
        if $(GCC_VERSION) != 2.x {
            KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -fno-rtti -fno-exceptions -fcheck-new -msoft-float -fapple-kext ;
        }
        else {
            KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -fno-rtti -fno-exceptions -fcheck-new -fvtable-thunks -msoft-float ;
            if $(MODULE_IOKIT) = YES {
                KERNEL_COMPILE_OPTIONS += -findirect-virtual-calls ;
            }
        }
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) ;
        if $(2:S) = .CPP {
            FLAGS on $(1) += -x c++ ;
        }
    }
    FLAGS on $(1) += -pipe ;
    if ( $(GCC_VERSION) != 2.x ) {
        FLAGS on $(1) += -fmessage-length=0 ;
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    if $(CPP_HEADER_SYMLINKS_DIR) {
        FLAGS on $(1) += "-I$(CPP_HEADER_SYMLINKS_DIR)" ;
    }
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # If the source file is in a subdirectory, then search that
    # subdirectory for headers
    if $(2:D) {
        HEADER_SEARCH_PATHS on $(1) += $(2:D) ;
    }
    # We must compile with the extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CC_FLAGS) ;
    # Add variant-specific flags
    local _VARIANT_FLAGS = $($(CC:BS)_$(VARIANT)_FLAGS) ;
    if $(_VARIANT_FLAGS) {
        FLAGS on $(1) += $(_VARIANT_FLAGS) ;
    }
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    # Pass the trusted-precomp file name to the compiler to keep track
    # of which precompiled headers it has already sanity checked.
    if $(GCC_VERSION) != 3.3 && $(GCC_VERSION) != 3.5 && $(OS) in MACOS DARWIN  &&  $(EFFECTIVE_PFE_FILE_$(ARCH)) = "" {
        FLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
    }
    if $(CPP_HEADERMAP_FILE) {
        FLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(1:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    if $(EFFECTIVE_PFE_FILE_$(ARCH)) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            if $(PREFIX_HEADER_CFLAGS_BASE) = -include {
                # GCC v3.3 / v3.5 PCH
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH):S=)" ;            
            }
            else {
                # GCC v3.1 PFE
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH))" ;
            }
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
            }
        }
    }
    if $(EFFECTIVE_PREFIX_HEADER) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            # GCC v2.95.2 cpp-precomp
            PREFIX_HEADER_CFLAGS on $(1) += -include "$(EFFECTIVE_PREFIX_HEADER)" ;
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PREFIX_HEADER) ;
            }
        }
    }
    _LD_FOR_LINKING = $(LDPLUSPLUS) ;
}

actions CompileCplusplus
{
    $(CPLUSPLUS) -c -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_CPLUSPLUSFLAGS)" $($(2)_COMPILER_FLAGS) $(2:Q) -o $(1:Q)
}

rule ProcessAssembly
{
    for VARIANT in $(BUILD_VARIANTS) {
    for ARCH in $(ARCHS) {
        local OBJECT_FILE ;
        local OBJECT_SUBDIR = $(OBJECT_FILE_DIR_$(VARIANT))$(/)$(ARCH) ;
        # $(2)_UNIQUENAME is defined only if the basename of the file isn't unique within the target.
        if $($(2)_UNIQUENAME) {
            OBJECT_FILE = $($(2)_UNIQUENAME:G=$(VARIANT)-$(ARCH)).o ;
        }
        else {
            OBJECT_FILE = $(2:D=:S=:G=$(VARIANT)-$(ARCH)).o ;
        }
        DEPENDS $(OBJECT_FILE) : $(OBJECT_SUBDIR) ;
        if ! $(OBJECT_SUBDIR) in $(PRODUCT_FILES) {
            Mkdir $(OBJECT_SUBDIR) ;
            PRODUCT_FILES += $(OBJECT_SUBDIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_SUBDIR) ;
            }
        }
        ARCH on $(OBJECT_FILE) = $(ARCH) ;
        PER_ARCH_ASFLAGS = $(PER_ARCH_ASFLAGS_$(ARCH)) ;
        if $(JAVA_BRIDGET_TARGET) {
            DEPENDS $(OBJECT_FILE) : $(JAVA_BRIDGET_TARGET) ;
        }
        OTHER_ASFLAGS on $(OBJECT_FILE) = $(OTHER_ASFLAGS) $(OTHER_ASFLAGS_$(VARIANT)) ;
        CompileC $(OBJECT_FILE) : $(2) ;
        if $(2:BS) != $(VECTOR_STUB:BS) {
            # add object file to object files and phase products
            # unless it is the compiled generated vector stub
            OBJECT_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            OBJECT_FILES_$(VARIANT)_$(ARCH) += $(OBJECT_FILE) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_FILE) ;
            }
        }
        LOCATE on $(OBJECT_FILE) = $(OBJECT_SUBDIR) ;
        if $(2) = $(MODULE_INFO_FILE) {
            MODULE_OBJECT_FILE_$(VARIANT) = $(OBJECT_FILE) ;
            LOCATE on $(MODULE_OBJECT_FILE_$(VARIANT)) = $(OBJECT_SUBDIR) ;
            DEPENDS $(1) : $(MODULE_OBJECT_FILE_$(VARIANT)) ;
        }
        else {
            # object file is added to linked files
            # unless it is the compiled generated vector stub
            if $(2:BS) != $(VECTOR_STUB:BS) {
                LINKED_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            }
        }
    }
    }
}

rule CompileAssembly
{
    # object file depends on the source file
    DEPENDS $(1) : $(2) ;
    # Initialize the flags, and set search paths to nothing
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_HEADERS) $(KERNEL_HEADERS)/bsd $(KERNEL_FRAMEWORK)/PrivateHeaders ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_ASFLAGS) -fno-common -nostdinc $(OPTIMIZATION_ASFLAGS) $(WARNING_ASFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_ASFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_ASFLAGS) $(WARNING_ASFLAGS) ;
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    if $(CPP_HEADER_SYMLINKS_DIR) {
        FLAGS on $(1) += "-I$(CPP_HEADER_SYMLINKS_DIR)" ;
    }
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;

    # If the source file is in a subdirectory, then search that
    # subdirectory for headers
    if $(2:D) {
        HEADER_SEARCH_PATHS on $(1) += $(2:D) ;
    }
    # We must compile with the extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add variant-specific flags
    local _VARIANT_FLAGS = $($(CC:BS)_$(VARIANT)_FLAGS) ;
    if $(_VARIANT_FLAGS) {
        FLAGS on $(1) += $(_VARIANT_FLAGS) ;
    }
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    # Pass the trusted-precomp file name to the compiler to keep track
    # of which precompiled headers it has already sanity checked.
    if $(GCC_VERSION) != 3.3 && $(GCC_VERSION) != 3.5 && $(OS) in MACOS DARWIN  &&  $(EFFECTIVE_PFE_FILE_$(ARCH)) = "" {
        FLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
    }
    if $(CPP_HEADERMAP_FILE) {
        FLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(1:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    if $(INDEX_GENERATION_PIPE_NAME) != "" {
        FLAGS on $(1) += "-fgen-index=$(INDEX_GENERATION_PIPE_NAME)" ;
    }
    if $(EFFECTIVE_PFE_FILE_$(ARCH)) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            if $(PREFIX_HEADER_CFLAGS_BASE) = -include {
                # GCC v3.3 / v3.5 PCH
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH):S=)" ;            
            }
            else {
                # GCC v3.1 PFE
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH))" ;
            }
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
            }
        }
    }
    if $(EFFECTIVE_PREFIX_HEADER) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            # GCC v2.95.2 cpp-precomp
            PREFIX_HEADER_CFLAGS on $(1) += -include "$(EFFECTIVE_PREFIX_HEADER)" ;
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PREFIX_HEADER) ;
            }
        }
    }
}

actions CompileAssembly
{
    $(CC) -c -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) $(PREFIX_HEADER_ASFLAGS:Q) "$(OTHER_ASFLAGS)" $($(2)_COMPILER_FLAGS) $(2:Q) -o $(1:Q)
}


rule ProcessFortran
{
    for VARIANT in $(BUILD_VARIANTS) {
    for ARCH in $(ARCHS) {
        local OBJECT_FILE ;
        local OBJECT_SUBDIR = $(OBJECT_FILE_DIR_$(VARIANT))$(/)$(ARCH) ;
        # $(2)_UNIQUENAME is defined only if the basename of the file isn't unique within the target.
        if $($(2)_UNIQUENAME) {
            OBJECT_FILE = $($(2)_UNIQUENAME:G=$(VARIANT)-$(ARCH)).o ;
        }
        else {
            OBJECT_FILE = $(2:D=:S=:G=$(VARIANT)-$(ARCH)).o ;
        }
        DEPENDS $(OBJECT_FILE) : $(OBJECT_SUBDIR) ;
        if ! $(OBJECT_SUBDIR) in $(PRODUCT_FILES) {
            Mkdir $(OBJECT_SUBDIR) ;
            PRODUCT_FILES += $(OBJECT_SUBDIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_SUBDIR) ;
            }
        }
        ARCH on $(OBJECT_FILE) = $(ARCH) ;
        PER_ARCH_FFLAGS = $(PER_ARCH_FFLAGS_$(ARCH)) ;
        if $(JAVA_BRIDGET_TARGET) {
            DEPENDS $(OBJECT_FILE) : $(JAVA_BRIDGET_TARGET) ;
        }
        OTHER_FFLAGS on $(OBJECT_FILE) = $(OTHER_FFLAGS) $(OTHER_FFLAGS_$(VARIANT)) ;
        CompileFortran $(OBJECT_FILE) : $(2) ;
        if $(2:BS) != $(VECTOR_STUB:BS) {
            # add object file to object files and phase products
            # unless it is the compiled generated vector stub
            OBJECT_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            OBJECT_FILES_$(VARIANT)_$(ARCH) += $(OBJECT_FILE) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_FILE) ;
            }
        }
        LOCATE on $(OBJECT_FILE) = $(OBJECT_SUBDIR) ;
        if $(2) = $(MODULE_INFO_FILE) {
            MODULE_OBJECT_FILE_$(VARIANT) = $(OBJECT_FILE) ;
            LOCATE on $(MODULE_OBJECT_FILE_$(VARIANT)) = $(OBJECT_SUBDIR) ;
            DEPENDS $(1) : $(MODULE_OBJECT_FILE_$(VARIANT)) ;
        }
        else {
            # object file is added to linked files
            # unless it is the compiled generated vector stub
            if $(2:BS) != $(VECTOR_STUB:BS) {
                LINKED_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            }
        }
    }
    }
}

rule CompileFortran
{
    # object file depends on the source file
    DEPENDS $(1) : $(2) ;
    # Initialize the flags, and set search paths to nothing
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_HEADERS) $(KERNEL_HEADERS)/bsd $(KERNEL_FRAMEWORK)/PrivateHeaders ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_FFLAGS) -fno-common -nostdinc $(OPTIMIZATION_FFLAGS) $(WARNING_FFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_FFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_FFLAGS) $(WARNING_FFLAGS) ;
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    if $(CPP_HEADER_SYMLINKS_DIR) {
        FLAGS on $(1) += "-I$(CPP_HEADER_SYMLINKS_DIR)" ;
    }
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;

    # If the source file is in a subdirectory, then search that
    # subdirectory for headers
    if $(2:D) {
        HEADER_SEARCH_PATHS on $(1) += $(2:D) ;
    }
    # We must compile with the extension-specific build flags
    FLAGS on $(1) += $($(2:S)_FFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    # Pass the trusted-precomp file name to the compiler to keep track
    # of which precompiled headers it has already sanity checked.
    if $(GCC_VERSION) != 3.3 && $(GCC_VERSION) != 3.5 && $(OS) in MACOS DARWIN  &&  $(EFFECTIVE_PFE_FILE_$(ARCH)) = "" {
        FLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
    }
    if $(CPP_HEADERMAP_FILE) {
        FLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(1:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    if $(INDEX_GENERATION_PIPE_NAME) != "" {
        FLAGS on $(1) += "-fgen-index=$(INDEX_GENERATION_PIPE_NAME)" ;
    }
    if $(EFFECTIVE_PFE_FILE_$(ARCH)) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            if $(PREFIX_HEADER_CFLAGS_BASE) = -include {
                # GCC v3.3 / v3.5 PCH
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH):S=)" ;            
            }
            else {
                # GCC v3.1 PFE
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH))" ;
            }
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
            }
        }
    }
    if $(EFFECTIVE_PREFIX_HEADER) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            # GCC v2.95.2 cpp-precomp
            PREFIX_HEADER_CFLAGS on $(1) += -include "$(EFFECTIVE_PREFIX_HEADER)" ;
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PREFIX_HEADER) ;
            }
        }
    }
}

actions CompileFortran
{
    $(CC) -c -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) $(PREFIX_HEADER_FFLAGS:Q) "$(OTHER_FFLAGS)" $($(2)_COMPILER_FLAGS) $(2:Q) -o $(1:Q)
}

VECTOR_SUFFIX default = ;
rule ProcessExportsFile
{
    if $(CFM_BRIDGE) = YES {
        local DYLIB_INSTALLED_NAME ;
        VECTOR_STUB default = $(DERIVED_FILE_DIR)$(/)$(1:B)Vector.s ;
        VECTOR_OBJECT_FILE default = $(TEMP_DIR)$(/)$(1:B)Vector.o ;
        if $(VECTOR_SUFFIX) {
            VECTOR_FRAGMENT_NAME default = CFMPriv_$(1:B)$(VECTOR_SUFFIX) ;
        }
        else {
            VECTOR_FRAGMENT_NAME default = CFMPriv_$(1:B) ;
        }
        DEPENDS $(VECTOR_STUB) : $(CURRENT_VERSION_DIR) ;
        DEPENDS $(VECTOR_STUB) : $(DERIVED_FILE_DIR) ;
        Mkdir $(CURRENT_VERSION_DIR) ;
        if $(INSTALL_PATH) {
            DYLIB_INSTALLED_NAME default = $(INSTALL_PATH)$(/)$(1:G=)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)$(1:B:G=) ;
            if $(DYNAMIC_LIBRARY_SUFFIX) {
                DYLIB_INSTALLED_NAME = $(DYLIB_INSTALLED_NAME)$(DYNAMIC_LIBRARY_SUFFIX) ;
            }
        }
        DYLIB_INSTALLED_NAME on $(1) = $(DYLIB_INSTALLED_NAME) ;
        GenerateVectorLibraryIntermediates $(VECTOR_STUB) $(VECTOR_OBJECT_FILE) : $(2) ;
        BUILD_PHASE_PRODUCTS += $(VECTOR_STUB) ;
    }
}

rule ProcessUsingMig
{
    local TEMP_FILES ;
    local FILE_BASE = $(2:B) ;

     if AbsolutePath in $($(2)_ATTRIBUTES) {
        FILE_BASE = $(DERIVED_FILE_DIR)$(2:DB) ;
    }
    if Client in $($(2)_ATTRIBUTES) {
        TEMP_FILES = $(FILE_BASE)User.c $(FILE_BASE).h ;
    }
    if Server in $($(2)_ATTRIBUTES) {
        TEMP_FILES += $(FILE_BASE)Server.c $(FILE_BASE)Server.h ;
    }
    if Client in $($(2)_ATTRIBUTES) || Server in $($(2)_ATTRIBUTES) {
        Mig $(TEMP_FILES) : $(2) ;
        DerivedFiles $(TEMP_FILES) ;
        DERIVED_FILES += $(TEMP_FILES) ;
        ProcessFiles $(1) : $(TEMP_FILES) ;
    }
}

rule ProcessUsingLex
{
    local TEMP_FILES ;
    local FILE_BASE = $(2:B) ;

    if AbsolutePath in $($(2)_ATTRIBUTES) {
        FILE_BASE = $(DERIVED_FILE_DIR)$(2:DB) ;
    }
    switch $(2:S) {
        case ".l" : TEMP_FILES += $(FILE_BASE).c ;
        case ".lm" : TEMP_FILES += $(FILE_BASE).m ;
        case ".LM" : TEMP_FILES += $(FILE_BASE).M ;
        case ".lmm" : TEMP_FILES += $(FILE_BASE).mm ;
        case ".lpp" : TEMP_FILES += $(FILE_BASE).cpp ;
        case ".LPP" : TEMP_FILES += $(FILE_BASE).CPP ;
        case ".lxx" : TEMP_FILES += $(FILE_BASE).cxx ;
        case ".LXX" : TEMP_FILES += $(FILE_BASE).CXX ;
    }
    DEPENDS $(TEMP_FILES) : $(DERIVED_FILE_DIR) ;
    Lex $(TEMP_FILES) : $(2) ;
    DerivedFiles $(TEMP_FILES) ;
    DERIVED_FILES += $(TEMP_FILES) ;
    ProcessFiles $(1) : $(TEMP_FILES) ;
}

rule ProcessUsingYacc
{
    local TEMP_FILES ;
    local FILE_BASE = $(2:B) ;

    if AbsolutePath in $($(2)_ATTRIBUTES) {
        FILE_BASE = $(DERIVED_FILE_DIR)$(2:DB) ;
    }
    switch $(2:S) {
        case ".y" : TEMP_FILES += $(FILE_BASE).c ;
        case ".ym" : TEMP_FILES += $(FILE_BASE).m ;
        case ".YM" : TEMP_FILES += $(FILE_BASE).M ;
        case ".ymm" : TEMP_FILES += $(FILE_BASE).mm ;
        case ".ypp" : TEMP_FILES += $(FILE_BASE).cpp ;
        case ".YPP" : TEMP_FILES += $(FILE_BASE).CPP ;
        case ".yxx" : TEMP_FILES += $(FILE_BASE).cxx ;
        case ".YXX" : TEMP_FILES += $(FILE_BASE).CXX ;
    }
    TEMP_FILES += $(FILE_BASE).h ;
    DEPENDS $(TEMP_FILES) : $(DERIVED_FILE_DIR) ;
    Yacc $(TEMP_FILES) : $(2) ;
    DerivedFiles $(TEMP_FILES) ;
    DERIVED_FILES += $(TEMP_FILES) ;
    ProcessFiles $(1) : $(TEMP_FILES) ;
}

rule ProcessUsingRPCGen
{
    local FILE_BASE = $(2:B) ;

    if AbsolutePath in $($(2)_ATTRIBUTES) {
        FILE_BASE = $(DERIVED_FILE_DIR)$(2:DB) ;
    }
    local TEMP_FILES = $(FILE_BASE)_xdr.c $(FILE_BASE).h ;
    DEPENDS $(TEMP_FILES) : $(DERIVED_FILE_DIR) ;
    RPCGen $(TEMP_FILES) : $(2) ;
    DerivedFiles $(TEMP_FILES) ;
    DERIVED_FILES += $(TEMP_FILES) ;
    ProcessFiles $(1) : $(TEMP_FILES) ;
}

rule ProcessUsingBridget
{
    Bridget $(1) : $(2) ;
}
# Copyright (c) 1999-2003 Apple Computer, Inc.
# All rights reserved.

# High level rules for build actions on targets

# Actions <product>
# Defines all available build actions
rule Actions
{
    Clean clean : $(1) ;
    BuildAction build : $(1) ;
    BuildAction copysrc : $(1) ;
    NOTFILE copysrc ;
    BuildAction copyhdrs : $(1) ;
    NOTFILE copyhdrs ;
    BuildAction copyrsrcs : $(1) ;
    NOTFILE copyrsrcs ;
    BuildAction install : $(1) ;
    BuildAction installdebugonly : $(1) ;
    NOTFILE installdebug ;
    BuildAction installprofileonly : $(1) ;
    NOTFILE installprofile ;
    BuildAction installdebugprofileonly : $(1) ;
    NOTFILE installdebugprofile ;
    BuildAction installsrc : $(1) ;
    NOTFILE installsrc ;
    BuildAction installhdrs : $(1) ;
    NOTFILE installhdrs ;
    BuildAction installrsrcs : $(1) ;
    NOTFILE installrsrcs ;
}

# Clean clean : <product>
# Deletes the product and the files associated with building it
rule Clean
{
    # locate built product and remove
    local BUILT_PRODUCT = $(2:G=) ;
    LOCATE on $(BUILT_PRODUCT) = $(TARGET_BUILD_DIR) ;
    Clean.Remove clean : $(BUILT_PRODUCT) ;

    # remove temporary directories
    Clean.Remove clean : $(TEMP_DIR) ;

    # Removal of archive in case of tools that are class archives,
    # this is which don't necessarily end with TOOL_SUFFIX.
    local ARCHIVE_SUFFIX ;
    local ARCHIVE_TARGET ;
    if $(JAVA_ARCHIVE_TYPE) = JAR {
        ARCHIVE_SUFFIX default = .jar ;
    }
    if $(JAVA_ARCHIVE_TYPE) = ZIP {
        ARCHIVE_SUFFIX default = .zip ;
    }
    ARCHIVE_SUFFIX default = "" ;
    ARCHIVE_TARGET = $(2:G=)$(ARCHIVE_SUFFIX) ;
    LOCATE on $(ARCHIVE_TARGET) = $(TARGET_BUILD_DIR) ;
    Clean.RemoveArchive clean : $(ARCHIVE_TARGET) ;
    # whole project content to remove on full clean
    Clean.Remove clean : $(PRECOMP_TRUSTFILE) ;
}

actions quietly piecemeal together existing Clean.Remove 
{
    $(RM) -rf $(2:Q)
}

actions quietly piecemeal together existing Clean.RemoveArchive
{
    if [ -f $(2:Q) ]; then
        $(RM) -rf $(2:Q)
    fi
}

rule BuildAction
{
    local ACTION_TARGET = $(2:G=$(1)BuildAction) ;
    ACTION on $(2) = $(ACTION) ;
    DEPENDS $(1) : $(ACTION_TARGET) ;
    DEPENDS $(ACTION_TARGET) : $(2) ;
    NOTFILE $(ACTION_TARGET) ;
}

# RunVariantHackScript varianthack : <product>
# Runs /AppleInternal/Developer/Tools/AppleInternalDebugAndProfileBuild.sh,
rule RunVariantHackScript
{
    if $(RC_JASPER) || $(INTERNAL_BUILD_VARIANTS_ONLY_IN_JASPER) != YES {
        local VARIANT_HACK_TARGET = $(1:G=varianthack) ;
        DEPENDS $(1) : $(VARIANT_HACK_TARGET) ;
        NOTFILE $(VARIANT_HACK_TARGET) ;
    }
}
actions exportvars RunVariantHackScript
{
    /bin/sh /AppleInternal/Developer/Tools/AppleInternalDebugAndProfileBuilder.sh $(INTERNAL_BUILD_VARIANTS)
}
# Copyright (c) 1999-2003 Apple Computer, Inc.
# All rights reserved.

include $(JAMFILE) ;
